{
  "ret": "<h1 id=\"i_ret\">'<code>ret</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>ret &lt;type&gt; &lt;value&gt;       ; Return a value from a non-void function\nret void                 ; Return from void function</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>ret</code>' instruction is used to return control flow\n(and optionally a value) from a function back to the caller.</p>\n<p>There are two forms of the '<code>ret</code>' instruction: one that\nreturns a value and then causes control flow, and one that just causes\ncontrol flow to occur.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>ret</code>' instruction optionally accepts a single\nargument, the return value. The type of the return value must be a\n'<code class=\"interpreted-text\" role=\"ref\">first\nclass &lt;t_firstclass&gt;</code>' type.</p>\n<p>A function is not <code class=\"interpreted-text\"\nrole=\"ref\">well formed &lt;wellformed&gt;</code> if it has a non-void\nreturn type and contains a '<code>ret</code>' instruction with no return\nvalue or a return value with a type that does not match its type, or if\nit has a void return type and contains a '<code>ret</code>' instruction\nwith a return value.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>When the '<code>ret</code>' instruction is executed, control flow\nreturns back to the calling function's context. If the caller is a\n\"<code class=\"interpreted-text\" role=\"ref\">call &lt;i_call&gt;</code>\"\ninstruction, execution continues at the instruction after the call. If\nthe caller was an \"<code class=\"interpreted-text\"\nrole=\"ref\">invoke &lt;i_invoke&gt;</code>\" instruction, execution\ncontinues at the beginning of the \"normal\" destination block. If the\ninstruction returns a value, that value shall set the call or invoke\ninstruction's return value.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>ret i32 5                       ; Return an integer value of 5\nret void                        ; Return from a void function\nret { i32, i8 } { i32 4, i8 2 } ; Return a struct of values 4 and 2</code></pre>\n",
  "br": "<h1 id=\"i_br\">'<code>br</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>br i1 &lt;cond&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;\nbr label &lt;dest&gt;          ; Unconditional branch</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>br</code>' instruction is used to cause control flow to\ntransfer to a different basic block in the current function. There are\ntwo forms of this instruction, corresponding to a conditional branch and\nan unconditional branch.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The conditional branch form of the '<code>br</code>' instruction\ntakes a single '<code>i1</code>' value and two '<code>label</code>'\nvalues. The unconditional form of the '<code>br</code>' instruction\ntakes a single '<code>label</code>' value as a target.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>Upon execution of a conditional '<code>br</code>' instruction, the\n'<code>i1</code>' argument is evaluated. If the value is\n<code>true</code>, control flows to the '<code>iftrue</code>'\n<code>label</code> argument. If \"cond\" is <code>false</code>, control\nflows to the '<code>iffalse</code>' <code>label</code> argument. If\n'<code>cond</code>' is <code>poison</code> or <code>undef</code>, this\ninstruction has undefined behavior.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>Test:\n  %cond = icmp eq i32 %a, %b\n  br i1 %cond, label %IfEqual, label %IfUnequal\nIfEqual:\n  ret i32 1\nIfUnequal:\n  ret i32 0</code></pre>\n",
  "switch": "<h1 id=\"i_switch\">'<code>switch</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>switch &lt;intty&gt; &lt;value&gt;, label &lt;defaultdest&gt; [ &lt;intty&gt; &lt;val&gt;, label &lt;dest&gt; ... ]</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>switch</code>' instruction is used to transfer control\nflow to one of several different places. It is a generalization of the\n'<code>br</code>' instruction, allowing a branch to occur to one of many\npossible destinations.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>switch</code>' instruction uses three parameters: an\ninteger comparison value '<code>value</code>', a default\n'<code>label</code>' destination, and an array of pairs of comparison\nvalue constants and '<code>label</code>'s. The table is not allowed to\ncontain duplicate constant entries.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The <code>switch</code> instruction specifies a table of values and\ndestinations. When the '<code>switch</code>' instruction is executed,\nthis table is searched for the given value. If the value is found,\ncontrol flow is transferred to the corresponding destination; otherwise,\ncontrol flow is transferred to the default destination. If\n'<code>value</code>' is <code>poison</code> or <code>undef</code>, this\ninstruction has undefined behavior.</p>\n<h2 id=\"implementation\">Implementation:</h2>\n<p>Depending on properties of the target machine and the particular\n<code>switch</code> instruction, this instruction may be code generated\nin different ways. For example, it could be generated as a series of\nchained conditional branches or with a lookup table.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>; Emulate a conditional br instruction\n%Val = zext i1 %value to i32\nswitch i32 %Val, label %truedest [ i32 0, label %falsedest ]\n\n; Emulate an unconditional br instruction\nswitch i32 0, label %dest [ ]\n\n; Implement a jump table:\nswitch i32 %val, label %otherwise [ i32 0, label %onzero\n                                    i32 1, label %onone\n                                    i32 2, label %ontwo ]</code></pre>\n",
  "indirectbr": "<h1 id=\"i_indirectbr\">'<code>indirectbr</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>indirectbr &lt;somety&gt;* &lt;address&gt;, [ label &lt;dest1&gt;, label &lt;dest2&gt;, ... ]</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>indirectbr</code>' instruction implements an indirect\nbranch to a label within the current function, whose address is\nspecified by \"<code>address</code>\". Address must be derived from a\n<code class=\"interpreted-text\"\nrole=\"ref\">blockaddress &lt;blockaddress&gt;</code> constant.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>address</code>' argument is the address of the label to\njump to. The rest of the arguments indicate the full set of possible\ndestinations that the address may point to. Blocks are allowed to occur\nmultiple times in the destination list, though this isn't particularly\nuseful.</p>\n<p>This destination list is required so that dataflow analysis has an\naccurate understanding of the CFG.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>Control transfers to the block specified in the address argument. All\npossible destination blocks must be listed in the label list, otherwise\nthis instruction has undefined behavior. This implies that jumps to\nlabels defined in other functions have undefined behavior as well. If\n'<code>address</code>' is <code>poison</code> or <code>undef</code>,\nthis instruction has undefined behavior.</p>\n<h2 id=\"implementation\">Implementation:</h2>\n<p>This is typically implemented with a jump through a register.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>indirectbr i8* %Addr, [ label %bb1, label %bb2, label %bb3 ]</code></pre>\n",
  "invoke": "<h1 id=\"i_invoke\">'<code>invoke</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = invoke [cconv] [ret attrs] [addrspace(&lt;num&gt;)] &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs]\n              [operand bundles] to label &lt;normal label&gt; unwind label &lt;exception label&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>invoke</code>' instruction causes control to transfer to a\nspecified function, with the possibility of control flow transfer to\neither the '<code>normal</code>' label or the '<code>exception</code>'\nlabel. If the callee function returns with the \"<code>ret</code>\"\ninstruction, control flow will return to the \"normal\" label. If the\ncallee (or any indirect callees) returns via the \"<code\nclass=\"interpreted-text\" role=\"ref\">resume &lt;i_resume&gt;</code>\"\ninstruction or other exception handling mechanism, control is\ninterrupted and continued at the dynamically nearest \"exception\"\nlabel.</p>\n<p>The '<code>exception</code>' label is a <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#overview\">landing pad</a> for the\nexception. As such, '<code>exception</code>' label is required to have\nthe \"<code class=\"interpreted-text\"\nrole=\"ref\">landingpad &lt;i_landingpad&gt;</code>\" instruction, which\ncontains the information about the behavior of the program after\nunwinding happens, as its first non-PHI instruction. The restrictions on\nthe \"<code>landingpad</code>\" instruction's tightly couples it to the\n\"<code>invoke</code>\" instruction, so that the important information\ncontained within the \"<code>landingpad</code>\" instruction can't be lost\nthrough normal code motion.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>This instruction requires several arguments:</p>\n<ol>\n<li>The optional \"cconv\" marker indicates which <code\nclass=\"interpreted-text\" role=\"ref\">calling\nconvention &lt;callingconv&gt;</code> the call should use. If none is\nspecified, the call defaults to using C calling conventions.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">Parameter Attributes &lt;paramattrs&gt;</code> list for\nreturn values. Only '<code>zeroext</code>', '<code>signext</code>', and\n'<code>inreg</code>' attributes are valid here.</li>\n<li>The optional addrspace attribute can be used to indicate the address\nspace of the called function. If it is not specified, the program\naddress space from the <code class=\"interpreted-text\"\nrole=\"ref\">datalayout string&lt;langref_datalayout&gt;</code> will be\nused.</li>\n<li>'<code>ty</code>': the type of the call instruction itself which is\nalso the type of the return value. Functions that return no value are\nmarked <code>void</code>.</li>\n<li>'<code>fnty</code>': shall be the signature of the function being\ninvoked. The argument types must match the types implied by this\nsignature. This type can be omitted if the function is not varargs.</li>\n<li>'<code>fnptrval</code>': An LLVM value containing a pointer to a\nfunction to be invoked. In most cases, this is a direct function\ninvocation, but indirect <code>invoke</code>'s are just as possible,\ncalling an arbitrary pointer to function value.</li>\n<li>'<code>function args</code>': argument list whose types match the\nfunction signature argument types and parameter attributes. All\narguments must be of <code class=\"interpreted-text\"\nrole=\"ref\">first class &lt;t_firstclass&gt;</code> type. If the function\nsignature indicates the function accepts a variable number of arguments,\nthe extra arguments can be specified.</li>\n<li>'<code>normal label</code>': the label reached when the called\nfunction executes a '<code>ret</code>' instruction.</li>\n<li>'<code>exception label</code>': the label reached when a callee\nreturns via the <code class=\"interpreted-text\"\nrole=\"ref\">resume &lt;i_resume&gt;</code> instruction or other exception\nhandling mechanism.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">function attributes &lt;fnattrs&gt;</code> list.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">operand bundles &lt;opbundles&gt;</code> list.</li>\n</ol>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>This instruction is designed to operate as a standard\n'<code>call</code>' instruction in most regards. The primary difference\nis that it establishes an association with a label, which is used by the\nruntime library to unwind the stack.</p>\n<p>This instruction is used in languages with destructors to ensure that\nproper cleanup is performed in the case of either a <code>longjmp</code>\nor a thrown exception. Additionally, this is important for\nimplementation of '<code>catch</code>' clauses in high-level languages\nthat support them.</p>\n<p>For the purposes of the SSA form, the definition of the value\nreturned by the '<code>invoke</code>' instruction is deemed to occur on\nthe edge from the current block to the \"normal\" label. If the callee\nunwinds then no return value is available.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%retval = invoke i32 @Test(i32 15) to label %Continue\n            unwind label %TestCleanup              ; i32:retval set\n%retval = invoke coldcc i32 %Testfnptr(i32 15) to label %Continue\n            unwind label %TestCleanup              ; i32:retval set</code></pre>\n",
  "callbr": "<h1 id=\"i_callbr\">'<code>callbr</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = callbr [cconv] [ret attrs] [addrspace(&lt;num&gt;)] &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs]\n              [operand bundles] to label &lt;fallthrough label&gt; [indirect labels]</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>callbr</code>' instruction causes control to transfer to a\nspecified function, with the possibility of control flow transfer to\neither the '<code>fallthrough</code>' label or one of the\n'<code>indirect</code>' labels.</p>\n<p>This instruction should only be used to implement the \"goto\" feature\nof gcc style inline assembly. Any other usage is an error in the IR\nverifier.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>This instruction requires several arguments:</p>\n<ol>\n<li>The optional \"cconv\" marker indicates which <code\nclass=\"interpreted-text\" role=\"ref\">calling\nconvention &lt;callingconv&gt;</code> the call should use. If none is\nspecified, the call defaults to using C calling conventions.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">Parameter Attributes &lt;paramattrs&gt;</code> list for\nreturn values. Only '<code>zeroext</code>', '<code>signext</code>', and\n'<code>inreg</code>' attributes are valid here.</li>\n<li>The optional addrspace attribute can be used to indicate the address\nspace of the called function. If it is not specified, the program\naddress space from the <code class=\"interpreted-text\"\nrole=\"ref\">datalayout string&lt;langref_datalayout&gt;</code> will be\nused.</li>\n<li>'<code>ty</code>': the type of the call instruction itself which is\nalso the type of the return value. Functions that return no value are\nmarked <code>void</code>.</li>\n<li>'<code>fnty</code>': shall be the signature of the function being\ncalled. The argument types must match the types implied by this\nsignature. This type can be omitted if the function is not varargs.</li>\n<li>'<code>fnptrval</code>': An LLVM value containing a pointer to a\nfunction to be called. In most cases, this is a direct function call,\nbut other <code>callbr</code>'s are just as possible, calling an\narbitrary pointer to function value.</li>\n<li>'<code>function args</code>': argument list whose types match the\nfunction signature argument types and parameter attributes. All\narguments must be of <code class=\"interpreted-text\"\nrole=\"ref\">first class &lt;t_firstclass&gt;</code> type. If the function\nsignature indicates the function accepts a variable number of arguments,\nthe extra arguments can be specified.</li>\n<li>'<code>fallthrough label</code>': the label reached when the inline\nassembly's execution exits the bottom.</li>\n<li>'<code>indirect labels</code>': the labels reached when a callee\ntransfers control to a location other than the\n'<code>fallthrough label</code>'. The blockaddress constant for these\nshould also be in the list of '<code>function args</code>'.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">function attributes &lt;fnattrs&gt;</code> list.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">operand bundles &lt;opbundles&gt;</code> list.</li>\n</ol>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>This instruction is designed to operate as a standard\n'<code>call</code>' instruction in most regards. The primary difference\nis that it establishes an association with additional labels to define\nwhere control flow goes after the call.</p>\n<p>The output values of a '<code>callbr</code>' instruction are\navailable only to the '<code>fallthrough</code>' block, not to any\n'<code>indirect</code>' blocks(s).</p>\n<p>The only use of this today is to implement the \"goto\" feature of gcc\ninline assembly where additional labels can be provided as locations for\nthe inline assembly to jump to.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>; &quot;asm goto&quot; without output constraints.\ncallbr void asm &quot;&quot;, &quot;r,X&quot;(i32 %x, i8 *blockaddress(@foo, %indirect))\n            to label %fallthrough [label %indirect]\n\n; &quot;asm goto&quot; with output constraints.\n&lt;result&gt; = callbr i32 asm &quot;&quot;, &quot;=r,r,X&quot;(i32 %x, i8 *blockaddress(@foo, %indirect))\n            to label %fallthrough [label %indirect]</code></pre>\n",
  "resume": "<h1 id=\"i_resume\">'<code>resume</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>resume &lt;type&gt; &lt;value&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>resume</code>' instruction is a terminator instruction\nthat has no successors.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>resume</code>' instruction requires one argument, which\nmust have the same type as the result of any '<code>landingpad</code>'\ninstruction in the same function.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>resume</code>' instruction resumes propagation of an\nexisting (in-flight) exception whose unwinding was interrupted with a\n<code class=\"interpreted-text\"\nrole=\"ref\">landingpad &lt;i_landingpad&gt;</code> instruction.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>resume { i8*, i32 } %exn</code></pre>\n",
  "catchswitch": "<h1 id=\"i_catchswitch\">'<code>catchswitch</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;resultval&gt; = catchswitch within &lt;parent&gt; [ label &lt;handler1&gt;, label &lt;handler2&gt;, ... ] unwind to caller\n&lt;resultval&gt; = catchswitch within &lt;parent&gt; [ label &lt;handler1&gt;, label &lt;handler2&gt;, ... ] unwind label &lt;default&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>catchswitch</code>' instruction is used by <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#overview\">LLVM's exception handling\nsystem</a> to describe the set of possible catch handlers that may be\nexecuted by the <code class=\"interpreted-text\"\nrole=\"ref\">EH personality routine &lt;personalityfn&gt;</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The <code>parent</code> argument is the token of the funclet that\ncontains the <code>catchswitch</code> instruction. If the\n<code>catchswitch</code> is not inside a funclet, this operand may be\nthe token <code>none</code>.</p>\n<p>The <code>default</code> argument is the label of another basic block\nbeginning with either a <code>cleanuppad</code> or\n<code>catchswitch</code> instruction. This unwind destination must be a\nlegal target with respect to the <code>parent</code> links, as described\nin the <a href=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#wineh-constraints\">exception\nhandling documentation</a>.</p>\n<p>The <code>handlers</code> are a nonempty list of successor blocks\nthat each begin with a <code class=\"interpreted-text\"\nrole=\"ref\">catchpad &lt;i_catchpad&gt;</code> instruction.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>Executing this instruction transfers control to one of the successors\nin <code>handlers</code>, if appropriate, or continues to unwind via the\nunwind label if present.</p>\n<p>The <code>catchswitch</code> is both a terminator and a \"pad\"\ninstruction, meaning that it must be both the first non-phi instruction\nand last instruction in the basic block. Therefore, it must be the only\nnon-phi instruction in the block.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>dispatch1:\n  %cs1 = catchswitch within none [label %handler0, label %handler1] unwind to caller\ndispatch2:\n  %cs2 = catchswitch within %parenthandler [label %handler0] unwind label %cleanup</code></pre>\n",
  "catchret": "<h1 id=\"i_catchret\">'<code>catchret</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>catchret from &lt;token&gt; to label &lt;normal&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>catchret</code>' instruction is a terminator instruction\nthat has a single successor.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The first argument to a '<code>catchret</code>' indicates which\n<code>catchpad</code> it exits. It must be a <code\nclass=\"interpreted-text\" role=\"ref\">catchpad &lt;i_catchpad&gt;</code>.\nThe second argument to a '<code>catchret</code>' specifies where control\nwill transfer to next.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>catchret</code>' instruction ends an existing (in-flight)\nexception whose unwinding was interrupted with a <code\nclass=\"interpreted-text\" role=\"ref\">catchpad &lt;i_catchpad&gt;</code>\ninstruction. The <code class=\"interpreted-text\"\nrole=\"ref\">personality function &lt;personalityfn&gt;</code> gets a\nchance to execute arbitrary code to, for example, destroy the active\nexception. Control then transfers to <code>normal</code>.</p>\n<p>The <code>token</code> argument must be a token produced by a\n<code>catchpad</code> instruction. If the specified\n<code>catchpad</code> is not the most-recently-entered not-yet-exited\nfunclet pad (as described in the <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#wineh-constraints\">EH documentation</a>),\nthe <code>catchret</code>'s behavior is undefined.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>catchret from %catch to label %continue</code></pre>\n",
  "cleanupret": "<h1 id=\"i_cleanupret\">'<code>cleanupret</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>cleanupret from &lt;value&gt; unwind label &lt;continue&gt;\ncleanupret from &lt;value&gt; unwind to caller</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>cleanupret</code>' instruction is a terminator instruction\nthat has an optional successor.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>cleanupret</code>' instruction requires one argument,\nwhich indicates which <code>cleanuppad</code> it exits, and must be a\n<code class=\"interpreted-text\"\nrole=\"ref\">cleanuppad &lt;i_cleanuppad&gt;</code>. If the specified\n<code>cleanuppad</code> is not the most-recently-entered not-yet-exited\nfunclet pad (as described in the <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#wineh-constraints\">EH documentation</a>),\nthe <code>cleanupret</code>'s behavior is undefined.</p>\n<p>The '<code>cleanupret</code>' instruction also has an optional\nsuccessor, <code>continue</code>, which must be the label of another\nbasic block beginning with either a <code>cleanuppad</code> or\n<code>catchswitch</code> instruction. This unwind destination must be a\nlegal target with respect to the <code>parent</code> links, as described\nin the <a href=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#wineh-constraints\">exception\nhandling documentation</a>.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>cleanupret</code>' instruction indicates to the <code\nclass=\"interpreted-text\"\nrole=\"ref\">personality function &lt;personalityfn&gt;</code> that one\n<code class=\"interpreted-text\"\nrole=\"ref\">cleanuppad &lt;i_cleanuppad&gt;</code> it transferred control\nto has ended. It transfers control to <code>continue</code> or unwinds\nout of the function.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>cleanupret from %cleanup unwind to caller\ncleanupret from %cleanup unwind label %continue</code></pre>\n",
  "unreachable": "<h1 id=\"i_unreachable\">'<code>unreachable</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>unreachable</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>unreachable</code>' instruction has no defined semantics.\nThis instruction is used to inform the optimizer that a particular\nportion of the code is not reachable. This can be used to indicate that\nthe code after a no-return function cannot be reached, and other\nfacts.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>unreachable</code>' instruction has no defined\nsemantics.</p>\n",
  "fneg": "<h1 id=\"i_fneg\">'<code>fneg</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fneg [fast-math flags]* &lt;ty&gt; &lt;op1&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fneg</code>' instruction returns the negation of its\noperand.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The argument to the '<code>fneg</code>' instruction must be a <code\nclass=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\nfloating-point values.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is a copy of the operand with its sign bit\nflipped. This instruction can also take any number of <code\nclass=\"interpreted-text\" role=\"ref\">fast-math\nflags &lt;fastmath&gt;</code>, which are optimization hints to enable\notherwise unsafe floating-point optimizations:</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = fneg float %val          ; yields float:result = -%var</code></pre>\n",
  "add": "<h1 id=\"i_add\">'<code>add</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = add &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;          ; yields ty:result\n&lt;result&gt; = add nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;      ; yields ty:result\n&lt;result&gt; = add nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;      ; yields ty:result\n&lt;result&gt; = add nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;  ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>add</code>' instruction returns the sum of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>add</code>' instruction must be <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code> or\n<code class=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code>\nof integer values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the integer sum of the two operands.</p>\n<p>If the sum has unsigned overflow, the result returned is the\nmathematical result modulo 2<sup>n</sup>, where n is the bit width of\nthe result.</p>\n<p>Because LLVM integers use a two's complement representation, this\ninstruction is appropriate for both signed and unsigned integers.</p>\n<p><code>nuw</code> and <code>nsw</code> stand for \"No Unsigned Wrap\"\nand \"No Signed Wrap\", respectively. If the <code>nuw</code> and/or\n<code>nsw</code> keywords are present, the result value of the\n<code>add</code> is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code> if unsigned and/or\nsigned overflow, respectively, occurs.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = add i32 4, %var          ; yields i32:result = 4 + %var</code></pre>\n",
  "fadd": "<h1 id=\"i_fadd\">'<code>fadd</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fadd [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fadd</code>' instruction returns the sum of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>fadd</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\nfloating-point values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the floating-point sum of the two operands.\nThis instruction is assumed to execute in the default <code\nclass=\"interpreted-text\" role=\"ref\">floating-point\nenvironment &lt;floatenv&gt;</code>. This instruction can also take any\nnumber of <code class=\"interpreted-text\" role=\"ref\">fast-math\nflags &lt;fastmath&gt;</code>, which are optimization hints to enable\notherwise unsafe floating-point optimizations:</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = fadd float 4.0, %var          ; yields float:result = 4.0 + %var</code></pre>\n",
  "sub": "<h1 id=\"i_sub\">'<code>sub</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;          ; yields ty:result\n&lt;result&gt; = sub nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;      ; yields ty:result\n&lt;result&gt; = sub nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;      ; yields ty:result\n&lt;result&gt; = sub nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;  ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>sub</code>' instruction returns the difference of its two\noperands.</p>\n<p>Note that the '<code>sub</code>' instruction is used to represent the\n'<code>neg</code>' instruction present in most other intermediate\nrepresentations.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>sub</code>' instruction must be <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code> or\n<code class=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code>\nof integer values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the integer difference of the two operands.</p>\n<p>If the difference has unsigned overflow, the result returned is the\nmathematical result modulo 2<sup>n</sup>, where n is the bit width of\nthe result.</p>\n<p>Because LLVM integers use a two's complement representation, this\ninstruction is appropriate for both signed and unsigned integers.</p>\n<p><code>nuw</code> and <code>nsw</code> stand for \"No Unsigned Wrap\"\nand \"No Signed Wrap\", respectively. If the <code>nuw</code> and/or\n<code>nsw</code> keywords are present, the result value of the\n<code>sub</code> is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code> if unsigned and/or\nsigned overflow, respectively, occurs.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = sub i32 4, %var          ; yields i32:result = 4 - %var\n&lt;result&gt; = sub i32 0, %val          ; yields i32:result = -%var</code></pre>\n",
  "fsub": "<h1 id=\"i_fsub\">'<code>fsub</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fsub [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fsub</code>' instruction returns the difference of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>fsub</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\nfloating-point values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the floating-point difference of the two\noperands. This instruction is assumed to execute in the default <code\nclass=\"interpreted-text\" role=\"ref\">floating-point\nenvironment &lt;floatenv&gt;</code>. This instruction can also take any\nnumber of <code class=\"interpreted-text\" role=\"ref\">fast-math\nflags &lt;fastmath&gt;</code>, which are optimization hints to enable\notherwise unsafe floating-point optimizations:</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = fsub float 4.0, %var           ; yields float:result = 4.0 - %var\n&lt;result&gt; = fsub float -0.0, %val          ; yields float:result = -%var</code></pre>\n",
  "mul": "<h1 id=\"i_mul\">'<code>mul</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;          ; yields ty:result\n&lt;result&gt; = mul nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;      ; yields ty:result\n&lt;result&gt; = mul nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;      ; yields ty:result\n&lt;result&gt; = mul nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;  ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>mul</code>' instruction returns the product of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>mul</code>' instruction must be <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code> or\n<code class=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code>\nof integer values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the integer product of the two operands.</p>\n<p>If the result of the multiplication has unsigned overflow, the result\nreturned is the mathematical result modulo 2<sup>n</sup>, where n is the\nbit width of the result.</p>\n<p>Because LLVM integers use a two's complement representation, and the\nresult is the same width as the operands, this instruction returns the\ncorrect result for both signed and unsigned integers. If a full product\n(e.g. <code>i32</code> * <code>i32</code> -&gt; <code>i64</code>) is\nneeded, the operands should be sign-extended or zero-extended as\nappropriate to the width of the full product.</p>\n<p><code>nuw</code> and <code>nsw</code> stand for \"No Unsigned Wrap\"\nand \"No Signed Wrap\", respectively. If the <code>nuw</code> and/or\n<code>nsw</code> keywords are present, the result value of the\n<code>mul</code> is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code> if unsigned and/or\nsigned overflow, respectively, occurs.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = mul i32 4, %var          ; yields i32:result = 4 * %var</code></pre>\n",
  "fmul": "<h1 id=\"i_fmul\">'<code>fmul</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fmul [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fmul</code>' instruction returns the product of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>fmul</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\nfloating-point values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the floating-point product of the two operands.\nThis instruction is assumed to execute in the default <code\nclass=\"interpreted-text\" role=\"ref\">floating-point\nenvironment &lt;floatenv&gt;</code>. This instruction can also take any\nnumber of <code class=\"interpreted-text\" role=\"ref\">fast-math\nflags &lt;fastmath&gt;</code>, which are optimization hints to enable\notherwise unsafe floating-point optimizations:</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = fmul float 4.0, %var          ; yields float:result = 4.0 * %var</code></pre>\n",
  "udiv": "<h1 id=\"i_udiv\">'<code>udiv</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = udiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;         ; yields ty:result\n&lt;result&gt; = udiv exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>udiv</code>' instruction returns the quotient of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>udiv</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\ninteger values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the unsigned integer quotient of the two\noperands.</p>\n<p>Note that unsigned integer division and signed integer division are\ndistinct operations; for signed integer division, use\n'<code>sdiv</code>'.</p>\n<p>Division by zero is undefined behavior. For vectors, if any element\nof the divisor is zero, the operation has undefined behavior.</p>\n<p>If the <code>exact</code> keyword is present, the result value of the\n<code>udiv</code> is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code> if %op1 is not a\nmultiple of %op2 (as such, \"((a udiv exact b) mul b) == a\").</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = udiv i32 4, %var          ; yields i32:result = 4 / %var</code></pre>\n",
  "sdiv": "<h1 id=\"i_sdiv\">'<code>sdiv</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;         ; yields ty:result\n&lt;result&gt; = sdiv exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>sdiv</code>' instruction returns the quotient of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>sdiv</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\ninteger values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the signed integer quotient of the two operands\nrounded towards zero.</p>\n<p>Note that signed integer division and unsigned integer division are\ndistinct operations; for unsigned integer division, use\n'<code>udiv</code>'.</p>\n<p>Division by zero is undefined behavior. For vectors, if any element\nof the divisor is zero, the operation has undefined behavior. Overflow\nalso leads to undefined behavior; this is a rare case, but can occur,\nfor example, by doing a 32-bit division of -2147483648 by -1.</p>\n<p>If the <code>exact</code> keyword is present, the result value of the\n<code>sdiv</code> is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code> if the result would\nbe rounded.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = sdiv i32 4, %var          ; yields i32:result = 4 / %var</code></pre>\n",
  "fdiv": "<h1 id=\"i_fdiv\">'<code>fdiv</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fdiv [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fdiv</code>' instruction returns the quotient of its two\noperands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>fdiv</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\nfloating-point values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the floating-point quotient of the two\noperands. This instruction is assumed to execute in the default <code\nclass=\"interpreted-text\" role=\"ref\">floating-point\nenvironment &lt;floatenv&gt;</code>. This instruction can also take any\nnumber of <code class=\"interpreted-text\" role=\"ref\">fast-math\nflags &lt;fastmath&gt;</code>, which are optimization hints to enable\notherwise unsafe floating-point optimizations:</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = fdiv float 4.0, %var          ; yields float:result = 4.0 / %var</code></pre>\n",
  "urem": "<h1 id=\"i_urem\">'<code>urem</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = urem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>urem</code>' instruction returns the remainder from the\nunsigned division of its two arguments.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>urem</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\ninteger values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>This instruction returns the unsigned integer <em>remainder</em> of a\ndivision. This instruction always performs an unsigned division to get\nthe remainder.</p>\n<p>Note that unsigned integer remainder and signed integer remainder are\ndistinct operations; for signed integer remainder, use\n'<code>srem</code>'.</p>\n<p>Taking the remainder of a division by zero is undefined behavior. For\nvectors, if any element of the divisor is zero, the operation has\nundefined behavior.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = urem i32 4, %var          ; yields i32:result = 4 % %var</code></pre>\n",
  "srem": "<h1 id=\"i_srem\">'<code>srem</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = srem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>srem</code>' instruction returns the remainder from the\nsigned division of its two operands. This instruction can also take\n<code class=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code>\nversions of the values in which case the elements must be integers.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>srem</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\ninteger values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>This instruction returns the <em>remainder</em> of a division (where\nthe result is either zero or has the same sign as the dividend,\n<code>op1</code>), not the <em>modulo</em> operator (where the result is\neither zero or has the same sign as the divisor, <code>op2</code>) of a\nvalue. For more information about the difference, see <a\nhref=\"http://mathforum.org/dr.math/problems/anne.4.28.99.html\">The Math\nForum</a>. For a table of how this is implemented in various languages,\nplease see <a\nhref=\"http://en.wikipedia.org/wiki/Modulo_operation\">Wikipedia: modulo\noperation</a>.</p>\n<p>Note that signed integer remainder and unsigned integer remainder are\ndistinct operations; for unsigned integer remainder, use\n'<code>urem</code>'.</p>\n<p>Taking the remainder of a division by zero is undefined behavior. For\nvectors, if any element of the divisor is zero, the operation has\nundefined behavior. Overflow also leads to undefined behavior; this is a\nrare case, but can occur, for example, by taking the remainder of a\n32-bit division of -2147483648 by -1. (The remainder doesn't actually\noverflow, but this rule lets srem be implemented using instructions that\nreturn both the result of the division and the remainder.)</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = srem i32 4, %var          ; yields i32:result = 4 % %var</code></pre>\n",
  "frem": "<h1 id=\"i_frem\">'<code>frem</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = frem [fast-math flags]* &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>frem</code>' instruction returns the remainder from the\ndivision of its two operands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>frem</code>' instruction must be\n<code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\nfloating-point values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is the floating-point remainder of the two\noperands. This is the same output as a libm '<code>fmod</code>'\nfunction, but without any possibility of setting <code>errno</code>. The\nremainder has the same sign as the dividend. This instruction is assumed\nto execute in the default <code class=\"interpreted-text\"\nrole=\"ref\">floating-point\nenvironment &lt;floatenv&gt;</code>. This instruction can also take any\nnumber of <code class=\"interpreted-text\" role=\"ref\">fast-math\nflags &lt;fastmath&gt;</code>, which are optimization hints to enable\notherwise unsafe floating-point optimizations:</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = frem float 4.0, %var          ; yields float:result = 4.0 % %var</code></pre>\n",
  "shl": "<h1 id=\"i_shl\">'<code>shl</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = shl &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;           ; yields ty:result\n&lt;result&gt; = shl nuw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;       ; yields ty:result\n&lt;result&gt; = shl nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;       ; yields ty:result\n&lt;result&gt; = shl nuw nsw &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>shl</code>' instruction returns the first operand shifted\nto the left a specified number of bits.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>Both arguments to the '<code>shl</code>' instruction must be the same\n<code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\ninteger type. '<code>op2</code>' is treated as an unsigned value.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The value produced is <code>op1</code> * 2<sup>op2</sup> mod\n2<sup>n</sup>, where <code>n</code> is the width of the result. If\n<code>op2</code> is (statically or dynamically) equal to or larger than\nthe number of bits in <code>op1</code>, this instruction returns a <code\nclass=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code>. If the arguments\nare vectors, each vector element of <code>op1</code> is shifted by the\ncorresponding shift amount in <code>op2</code>.</p>\n<p>If the <code>nuw</code> keyword is present, then the shift produces a\npoison value if it shifts out any non-zero bits. If the <code>nsw</code>\nkeyword is present, then the shift produces a poison value if it shifts\nout any bits that disagree with the resultant sign bit.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = shl i32 4, %var   ; yields i32: 4 &lt;&lt; %var\n&lt;result&gt; = shl i32 4, 2      ; yields i32: 16\n&lt;result&gt; = shl i32 1, 10     ; yields i32: 1024\n&lt;result&gt; = shl i32 1, 32     ; undefined\n&lt;result&gt; = shl &lt;2 x i32&gt; &lt; i32 1, i32 1&gt;, &lt; i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 2, i32 4&gt;</code></pre>\n",
  "lshr": "<h1 id=\"i_lshr\">'<code>lshr</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = lshr &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;         ; yields ty:result\n&lt;result&gt; = lshr exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>lshr</code>' instruction (logical shift right) returns the\nfirst operand shifted to the right a specified number of bits with zero\nfill.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>Both arguments to the '<code>lshr</code>' instruction must be the\nsame <code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\ninteger type. '<code>op2</code>' is treated as an unsigned value.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>This instruction always performs a logical shift right operation. The\nmost significant bits of the result will be filled with zero bits after\nthe shift. If <code>op2</code> is (statically or dynamically) equal to\nor larger than the number of bits in <code>op1</code>, this instruction\nreturns a <code class=\"interpreted-text\" role=\"ref\">poison\nvalue &lt;poisonvalues&gt;</code>. If the arguments are vectors, each\nvector element of <code>op1</code> is shifted by the corresponding shift\namount in <code>op2</code>.</p>\n<p>If the <code>exact</code> keyword is present, the result value of the\n<code>lshr</code> is a poison value if any of the bits shifted out are\nnon-zero.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = lshr i32 4, 1   ; yields i32:result = 2\n&lt;result&gt; = lshr i32 4, 2   ; yields i32:result = 1\n&lt;result&gt; = lshr i8  4, 3   ; yields i8:result = 0\n&lt;result&gt; = lshr i8 -2, 1   ; yields i8:result = 0x7F\n&lt;result&gt; = lshr i32 1, 32  ; undefined\n&lt;result&gt; = lshr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 0x7FFFFFFF, i32 1&gt;</code></pre>\n",
  "ashr": "<h1 id=\"i_ashr\">'<code>ashr</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = ashr &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;         ; yields ty:result\n&lt;result&gt; = ashr exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>ashr</code>' instruction (arithmetic shift right) returns\nthe first operand shifted to the right a specified number of bits with\nsign extension.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>Both arguments to the '<code>ashr</code>' instruction must be the\nsame <code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code> of\ninteger type. '<code>op2</code>' is treated as an unsigned value.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>This instruction always performs an arithmetic shift right operation,\nThe most significant bits of the result will be filled with the sign bit\nof <code>op1</code>. If <code>op2</code> is (statically or dynamically)\nequal to or larger than the number of bits in <code>op1</code>, this\ninstruction returns a <code class=\"interpreted-text\" role=\"ref\">poison\nvalue &lt;poisonvalues&gt;</code>. If the arguments are vectors, each\nvector element of <code>op1</code> is shifted by the corresponding shift\namount in <code>op2</code>.</p>\n<p>If the <code>exact</code> keyword is present, the result value of the\n<code>ashr</code> is a poison value if any of the bits shifted out are\nnon-zero.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = ashr i32 4, 1   ; yields i32:result = 2\n&lt;result&gt; = ashr i32 4, 2   ; yields i32:result = 1\n&lt;result&gt; = ashr i8  4, 3   ; yields i8:result = 0\n&lt;result&gt; = ashr i8 -2, 1   ; yields i8:result = -1\n&lt;result&gt; = ashr i32 1, 32  ; undefined\n&lt;result&gt; = ashr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt; i32 1, i32 3&gt;   ; yields: result=&lt;2 x i32&gt; &lt; i32 -1, i32 0&gt;</code></pre>\n",
  "and": "<h1 id=\"i_and\">'<code>and</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>and</code>' instruction returns the bitwise logical and of\nits two operands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>and</code>' instruction must be <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code> or\n<code class=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code>\nof integer values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The truth table used for the '<code>and</code>' instruction is:</p>\n<table style=\"width:25%;\">\n<colgroup>\n<col style=\"width: 8%\" />\n<col style=\"width: 8%\" />\n<col style=\"width: 8%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td>In0</td>\n<td>In1</td>\n<td>Out</td>\n</tr>\n<tr class=\"even\">\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n</tr>\n<tr class=\"odd\">\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n</tr>\n<tr class=\"even\">\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n</tr>\n<tr class=\"odd\">\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = and i32 4, %var         ; yields i32:result = 4 &amp; %var\n&lt;result&gt; = and i32 15, 40          ; yields i32:result = 8\n&lt;result&gt; = and i32 4, 8            ; yields i32:result = 0</code></pre>\n",
  "or": "<h1 id=\"i_or\">'<code>or</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>or</code>' instruction returns the bitwise logical\ninclusive or of its two operands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>or</code>' instruction must be <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code> or\n<code class=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code>\nof integer values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The truth table used for the '<code>or</code>' instruction is:</p>\n<table style=\"width:25%;\">\n<colgroup>\n<col style=\"width: 8%\" />\n<col style=\"width: 8%\" />\n<col style=\"width: 8%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td>In0</td>\n<td>In1</td>\n<td>Out</td>\n</tr>\n<tr class=\"even\">\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n</tr>\n<tr class=\"odd\">\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n</tr>\n<tr class=\"even\">\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n</tr>\n<tr class=\"odd\">\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"example\">Example:</h2>\n<pre><code>&lt;result&gt; = or i32 4, %var         ; yields i32:result = 4 | %var\n&lt;result&gt; = or i32 15, 40          ; yields i32:result = 47\n&lt;result&gt; = or i32 4, 8            ; yields i32:result = 12</code></pre>\n",
  "xor": "<h1 id=\"i_xor\">'<code>xor</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = xor &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>xor</code>' instruction returns the bitwise logical\nexclusive or of its two operands. The <code>xor</code> is used to\nimplement the \"one's complement\" operation, which is the \"~\" operator in\nC.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The two arguments to the '<code>xor</code>' instruction must be <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code> or\n<code class=\"interpreted-text\" role=\"ref\">vector &lt;t_vector&gt;</code>\nof integer values. Both arguments must have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The truth table used for the '<code>xor</code>' instruction is:</p>\n<table style=\"width:25%;\">\n<colgroup>\n<col style=\"width: 8%\" />\n<col style=\"width: 8%\" />\n<col style=\"width: 8%\" />\n</colgroup>\n<tbody>\n<tr class=\"odd\">\n<td>In0</td>\n<td>In1</td>\n<td>Out</td>\n</tr>\n<tr class=\"even\">\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n</tr>\n<tr class=\"odd\">\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n</tr>\n<tr class=\"even\">\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n</tr>\n<tr class=\"odd\">\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>1</p>\n</blockquote></td>\n<td><blockquote>\n<p>0</p>\n</blockquote></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = xor i32 4, %var         ; yields i32:result = 4 ^ %var\n&lt;result&gt; = xor i32 15, 40          ; yields i32:result = 39\n&lt;result&gt; = xor i32 4, 8            ; yields i32:result = 12\n&lt;result&gt; = xor i32 %V, -1          ; yields i32:result = ~%V</code></pre>\n<h3 id=\"vector-operations\">Vector Operations</h3>\n<p>LLVM supports several instructions to represent vector operations in\na target-independent manner. These instructions cover the element-access\nand vector-specific operations needed to process vectors effectively.\nWhile LLVM does directly support these vector operations, many\nsophisticated algorithms will want to use target-specific intrinsics to\ntake full advantage of a specific target.</p>\n",
  "extractelement": "<h1 id=\"i_extractelement\">'<code>extractelement</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = extractelement &lt;n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty2&gt; &lt;idx&gt;  ; yields &lt;ty&gt;\n&lt;result&gt; = extractelement &lt;vscale x n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty2&gt; &lt;idx&gt; ; yields &lt;ty&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>extractelement</code>' instruction extracts a single\nscalar element from a vector at a specified index.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The first operand of an '<code>extractelement</code>' instruction is\na value of <code class=\"interpreted-text\"\nrole=\"ref\">vector &lt;t_vector&gt;</code> type. The second operand is an\nindex indicating the position from which to extract the element. The\nindex may be a variable of any integer type.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The result is a scalar of the same type as the element type of\n<code>val</code>. Its value is the value at position <code>idx</code> of\n<code>val</code>. If <code>idx</code> exceeds the length of\n<code>val</code> for a fixed-length vector, the result is a <code\nclass=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code>. For a scalable\nvector, if the value of <code>idx</code> exceeds the runtime length of\nthe vector, the result is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = extractelement &lt;4 x i32&gt; %vec, i32 0    ; yields i32</code></pre>\n",
  "insertelement": "<h1 id=\"i_insertelement\">'<code>insertelement</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = insertelement &lt;n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty&gt; &lt;elt&gt;, &lt;ty2&gt; &lt;idx&gt;    ; yields &lt;n x &lt;ty&gt;&gt;\n&lt;result&gt; = insertelement &lt;vscale x n x &lt;ty&gt;&gt; &lt;val&gt;, &lt;ty&gt; &lt;elt&gt;, &lt;ty2&gt; &lt;idx&gt; ; yields &lt;vscale x n x &lt;ty&gt;&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>insertelement</code>' instruction inserts a scalar element\ninto a vector at a specified index.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The first operand of an '<code>insertelement</code>' instruction is a\nvalue of <code class=\"interpreted-text\"\nrole=\"ref\">vector &lt;t_vector&gt;</code> type. The second operand is a\nscalar value whose type must equal the element type of the first\noperand. The third operand is an index indicating the position at which\nto insert the value. The index may be a variable of any integer\ntype.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The result is a vector of the same type as <code>val</code>. Its\nelement values are those of <code>val</code> except at position\n<code>idx</code>, where it gets the value <code>elt</code>. If\n<code>idx</code> exceeds the length of <code>val</code> for a\nfixed-length vector, the result is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code>. For a scalable\nvector, if the value of <code>idx</code> exceeds the runtime length of\nthe vector, the result is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = insertelement &lt;4 x i32&gt; %vec, i32 1, i32 0    ; yields &lt;4 x i32&gt;</code></pre>\n",
  "shufflevector": "<h1 id=\"i_shufflevector\">'<code>shufflevector</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = shufflevector &lt;n x &lt;ty&gt;&gt; &lt;v1&gt;, &lt;n x &lt;ty&gt;&gt; &lt;v2&gt;, &lt;m x i32&gt; &lt;mask&gt;    ; yields &lt;m x &lt;ty&gt;&gt;\n&lt;result&gt; = shufflevector &lt;vscale x n x &lt;ty&gt;&gt; &lt;v1&gt;, &lt;vscale x n x &lt;ty&gt;&gt; v2, &lt;vscale x m x i32&gt; &lt;mask&gt;  ; yields &lt;vscale x m x &lt;ty&gt;&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>shufflevector</code>' instruction constructs a permutation\nof elements from two input vectors, returning a vector with the same\nelement type as the input and length that is the same as the shuffle\nmask.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The first two operands of a '<code>shufflevector</code>' instruction\nare vectors with the same type. The third argument is a shuffle mask\nvector constant whose element type is <code>i32</code>. The mask vector\nelements must be constant integers or <code>undef</code> values. The\nresult of the instruction is a vector whose length is the same as the\nshuffle mask and whose element type is the same as the element type of\nthe first two operands.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The elements of the two input vectors are numbered from left to right\nacross both of the vectors. For each element of the result vector, the\nshuffle mask selects an element from one of the input vectors to copy to\nthe result. Non-negative elements in the mask represent an index into\nthe concatenated pair of input vectors.</p>\n<p>If the shuffle mask is undefined, the result vector is undefined. If\nthe shuffle mask selects an undefined element from one of the input\nvectors, the resulting element is undefined. An undefined element in the\nmask vector specifies that the resulting element is undefined. An\nundefined element in the mask vector prevents a poisoned vector element\nfrom propagating.</p>\n<p>For scalable vectors, the only valid mask values at present are\n<code>zeroinitializer</code> and <code>undef</code>, since we cannot\nwrite all indices as literals for a vector with a length unknown at\ncompile time.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2,\n                        &lt;4 x i32&gt; &lt;i32 0, i32 4, i32 1, i32 5&gt;  ; yields &lt;4 x i32&gt;\n&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; undef,\n                        &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;  ; yields &lt;4 x i32&gt; - Identity shuffle.\n&lt;result&gt; = shufflevector &lt;8 x i32&gt; %v1, &lt;8 x i32&gt; undef,\n                        &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;  ; yields &lt;4 x i32&gt;\n&lt;result&gt; = shufflevector &lt;4 x i32&gt; %v1, &lt;4 x i32&gt; %v2,\n                        &lt;8 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 &gt;  ; yields &lt;8 x i32&gt;</code></pre>\n<h3 id=\"aggregate-operations\">Aggregate Operations</h3>\n<p>LLVM supports several instructions for working with <code\nclass=\"interpreted-text\" role=\"ref\">aggregate &lt;t_aggregate&gt;</code>\nvalues.</p>\n",
  "extractvalue": "<h1 id=\"i_extractvalue\">'<code>extractvalue</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = extractvalue &lt;aggregate type&gt; &lt;val&gt;, &lt;idx&gt;{, &lt;idx&gt;}*</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>extractvalue</code>' instruction extracts the value of a\nmember field from an <code class=\"interpreted-text\"\nrole=\"ref\">aggregate &lt;t_aggregate&gt;</code> value.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The first operand of an '<code>extractvalue</code>' instruction is a\nvalue of <code class=\"interpreted-text\"\nrole=\"ref\">struct &lt;t_struct&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">array &lt;t_array&gt;</code> type.\nThe other operands are constant indices to specify which value to\nextract in a similar manner as indices in a '<code>getelementptr</code>'\ninstruction.</p>\n<p>The major differences to <code>getelementptr</code> indexing are:</p>\n<ul>\n<li>Since the value being indexed is not a pointer, the first index is\nomitted and assumed to be zero.</li>\n<li>At least one index must be specified.</li>\n<li>Not only struct indices but also array indices must be in\nbounds.</li>\n</ul>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The result is the value at the position in the aggregate specified by\nthe index operands.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = extractvalue {i32, float} %agg, 0    ; yields i32</code></pre>\n",
  "insertvalue": "<h1 id=\"i_insertvalue\">'<code>insertvalue</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = insertvalue &lt;aggregate type&gt; &lt;val&gt;, &lt;ty&gt; &lt;elt&gt;, &lt;idx&gt;{, &lt;idx&gt;}*    ; yields &lt;aggregate type&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>insertvalue</code>' instruction inserts a value into a\nmember field in an <code class=\"interpreted-text\"\nrole=\"ref\">aggregate &lt;t_aggregate&gt;</code> value.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The first operand of an '<code>insertvalue</code>' instruction is a\nvalue of <code class=\"interpreted-text\"\nrole=\"ref\">struct &lt;t_struct&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">array &lt;t_array&gt;</code> type.\nThe second operand is a first-class value to insert. The following\noperands are constant indices indicating the position at which to insert\nthe value in a similar manner as indices in a\n'<code>extractvalue</code>' instruction. The value to insert must have\nthe same type as the value identified by the indices.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The result is an aggregate of the same type as <code>val</code>. Its\nvalue is that of <code>val</code> except that the value at the position\nspecified by the indices is that of <code>elt</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%agg1 = insertvalue {i32, float} undef, i32 1, 0              ; yields {i32 1, float undef}\n%agg2 = insertvalue {i32, float} %agg1, float %val, 1         ; yields {i32 1, float %val}\n%agg3 = insertvalue {i32, {float}} undef, float %val, 1, 0    ; yields {i32 undef, {float %val}}</code></pre>\n",
  "alloca": "<h1 id=\"i_alloca\">'<code>alloca</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = alloca [inalloca] &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;] [, addrspace(&lt;num&gt;)]     ; yields type addrspace(num)*:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>alloca</code>' instruction allocates memory on the stack\nframe of the currently executing function, to be automatically released\nwhen this function returns to its caller. If the address space is not\nexplicitly specified, the object is allocated in the alloca address\nspace from the <code class=\"interpreted-text\"\nrole=\"ref\">datalayout string&lt;langref_datalayout&gt;</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>alloca</code>' instruction allocates\n<code>sizeof(&lt;type&gt;)*NumElements</code> bytes of memory on the\nruntime stack, returning a pointer of the appropriate type to the\nprogram. If \"NumElements\" is specified, it is the number of elements\nallocated, otherwise \"NumElements\" is defaulted to be one. If a constant\nalignment is specified, the value result of the allocation is guaranteed\nto be aligned to at least that boundary. The alignment may not be\ngreater than <code>1 &lt;&lt; 32</code>. If not specified, or if zero,\nthe target can choose to align the allocation on any convenient boundary\ncompatible with the type.</p>\n<p>'<code>type</code>' may be any sized type.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>Memory is allocated; a pointer is returned. The allocated memory is\nuninitialized, and loading from uninitialized memory produces an\nundefined value. The operation itself is undefined if there is\ninsufficient stack space for the allocation.'<code>alloca</code>'d\nmemory is automatically released when the function returns. The\n'<code>alloca</code>' instruction is commonly used to represent\nautomatic variables that must have an address available. When the\nfunction returns (either with the <code>ret</code> or\n<code>resume</code> instructions), the memory is reclaimed. Allocating\nzero bytes is legal, but the returned pointer may not be unique. The\norder in which memory is allocated (ie., which way the stack grows) is\nnot specified.</p>\n<p>Note that '<code>alloca</code>' outside of the alloca address space\nfrom the <code class=\"interpreted-text\"\nrole=\"ref\">datalayout string&lt;langref_datalayout&gt;</code> is\nmeaningful only if the target has assigned it a semantics.</p>\n<p>If the returned pointer is used by <code class=\"interpreted-text\"\nrole=\"ref\">llvm.lifetime.start &lt;int_lifestart&gt;</code>, the\nreturned object is initially dead. See <code class=\"interpreted-text\"\nrole=\"ref\">llvm.lifetime.start &lt;int_lifestart&gt;</code> and <code\nclass=\"interpreted-text\"\nrole=\"ref\">llvm.lifetime.end &lt;int_lifeend&gt;</code> for the precise\nsemantics of lifetime-manipulating intrinsics.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%ptr = alloca i32                             ; yields i32*:ptr\n%ptr = alloca i32, i32 4                      ; yields i32*:ptr\n%ptr = alloca i32, i32 4, align 1024          ; yields i32*:ptr\n%ptr = alloca i32, align 1024                 ; yields i32*:ptr</code></pre>\n",
  "load": "<h1 id=\"i_load\">'<code>load</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = load [volatile] &lt;ty&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;nontemp_node&gt;][, !invariant.load !&lt;empty_node&gt;][, !invariant.group !&lt;empty_node&gt;][, !nonnull !&lt;empty_node&gt;][, !dereferenceable !&lt;deref_bytes_node&gt;][, !dereferenceable_or_null !&lt;deref_bytes_node&gt;][, !align !&lt;align_node&gt;][, !noundef !&lt;empty_node&gt;]\n&lt;result&gt; = load atomic [volatile] &lt;ty&gt;, &lt;ty&gt;* &lt;pointer&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;empty_node&gt;]\n!&lt;nontemp_node&gt; = !{ i32 1 }\n!&lt;empty_node&gt; = !{}\n!&lt;deref_bytes_node&gt; = !{ i64 &lt;dereferenceable_bytes&gt; }\n!&lt;align_node&gt; = !{ i64 &lt;value_alignment&gt; }</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>load</code>' instruction is used to read from memory.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The argument to the <code>load</code> instruction specifies the\nmemory address from which to load. The type specified must be a <code\nclass=\"interpreted-text\"\nrole=\"ref\">first class &lt;t_firstclass&gt;</code> type of known size\n(i.e. not containing an <code class=\"interpreted-text\"\nrole=\"ref\">opaque structural type &lt;t_opaque&gt;</code>). If the\n<code>load</code> is marked as <code>volatile</code>, then the optimizer\nis not allowed to modify the number or order of execution of this\n<code>load</code> with other <code class=\"interpreted-text\"\nrole=\"ref\">volatile operations &lt;volatile&gt;</code>.</p>\n<p>If the <code>load</code> is marked as <code>atomic</code>, it takes\nan extra <code class=\"interpreted-text\" role=\"ref\">ordering\n&lt;ordering&gt;</code> and optional\n<code>syncscope(\"&lt;target-scope&gt;\")</code> argument. The\n<code>release</code> and <code>acq_rel</code> orderings are not valid on\n<code>load</code> instructions. Atomic loads produce <code\nclass=\"interpreted-text\" role=\"ref\">defined &lt;memmodel&gt;</code>\nresults when they may see multiple atomic stores. The type of the\npointee must be an integer, pointer, or floating-point type whose bit\nwidth is a power of two greater than or equal to eight and less than or\nequal to a target-specific size limit. <code>align</code> must be\nexplicitly specified on atomic loads, and the load has undefined\nbehavior if the alignment is not set to a value which is at least the\nsize in bytes of the pointee. <code>!nontemporal</code> does not have\nany defined semantics for atomic loads.</p>\n<p>The optional constant <code>align</code> argument specifies the\nalignment of the operation (that is, the alignment of the memory\naddress). A value of 0 or an omitted <code>align</code> argument means\nthat the operation has the ABI alignment for the target. It is the\nresponsibility of the code emitter to ensure that the alignment\ninformation is correct. Overestimating the alignment results in\nundefined behavior. Underestimating the alignment may produce less\nefficient code. An alignment of 1 is always safe. The maximum possible\nalignment is <code>1 &lt;&lt; 32</code>. An alignment value higher than\nthe size of the loaded type implies memory up to the alignment value\nbytes can be safely loaded without trapping in the default address\nspace. Access of the high bytes can interfere with debugging tools, so\nshould not be accessed if the function has the\n<code>sanitize_thread</code> or <code>sanitize_address</code>\nattributes.</p>\n<p>The optional <code>!nontemporal</code> metadata must reference a\nsingle metadata name <code>&lt;nontemp_node&gt;</code> corresponding to\na metadata node with one <code>i32</code> entry of value 1. The\nexistence of the <code>!nontemporal</code> metadata on the instruction\ntells the optimizer and code generator that this load is not expected to\nbe reused in the cache. The code generator may select special\ninstructions to save cache bandwidth, such as the <code>MOVNT</code>\ninstruction on x86.</p>\n<p>The optional <code>!invariant.load</code> metadata must reference a\nsingle metadata name <code>&lt;empty_node&gt;</code> corresponding to a\nmetadata node with no entries. If a load instruction tagged with the\n<code>!invariant.load</code> metadata is executed, the memory location\nreferenced by the load has to contain the same value at all points in\nthe program where the memory location is dereferenceable; otherwise, the\nbehavior is undefined.</p>\n<dl>\n<dt>The optional <code>!invariant.group</code> metadata must reference a\nsingle metadata name</dt>\n<dd>\n<p><code>&lt;empty_node&gt;</code> corresponding to a metadata node with\nno entries. See <code>invariant.group</code> metadata <code\nclass=\"interpreted-text\"\nrole=\"ref\">invariant.group &lt;md_invariant.group&gt;</code>.</p>\n</dd>\n</dl>\n<p>The optional <code>!nonnull</code> metadata must reference a single\nmetadata name <code>&lt;empty_node&gt;</code> corresponding to a\nmetadata node with no entries. The existence of the\n<code>!nonnull</code> metadata on the instruction tells the optimizer\nthat the value loaded is known to never be null. If the value is null at\nruntime, the behavior is undefined. This is analogous to the\n<code>nonnull</code> attribute on parameters and return values. This\nmetadata can only be applied to loads of a pointer type.</p>\n<p>The optional <code>!dereferenceable</code> metadata must reference a\nsingle metadata name <code>&lt;deref_bytes_node&gt;</code> corresponding\nto a metadata node with one <code>i64</code> entry. See\n<code>dereferenceable</code> metadata <code class=\"interpreted-text\"\nrole=\"ref\">dereferenceable &lt;md_dereferenceable&gt;</code>.</p>\n<p>The optional <code>!dereferenceable_or_null</code> metadata must\nreference a single metadata name <code>&lt;deref_bytes_node&gt;</code>\ncorresponding to a metadata node with one <code>i64</code> entry. See\n<code>dereferenceable_or_null</code> metadata <code\nclass=\"interpreted-text\" role=\"ref\">dereferenceable_or_null\n&lt;md_dereferenceable_or_null&gt;</code>.</p>\n<p>The optional <code>!align</code> metadata must reference a single\nmetadata name <code>&lt;align_node&gt;</code> corresponding to a\nmetadata node with one <code>i64</code> entry. The existence of the\n<code>!align</code> metadata on the instruction tells the optimizer that\nthe value loaded is known to be aligned to a boundary specified by the\ninteger value in the metadata node. The alignment must be a power of 2.\nThis is analogous to the ''align'' attribute on parameters and return\nvalues. This metadata can only be applied to loads of a pointer type. If\nthe returned value is not appropriately aligned at runtime, the behavior\nis undefined.</p>\n<p>The optional <code>!noundef</code> metadata must reference a single\nmetadata name <code>&lt;empty_node&gt;</code> corresponding to a node\nwith no entries. The existence of <code>!noundef</code> metadata on the\ninstruction tells the optimizer that the value loaded is known to be\n<code class=\"interpreted-text\"\nrole=\"ref\">well defined &lt;welldefinedvalues&gt;</code>. If the value\nisn't well defined, the behavior is undefined.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The location of memory pointed to is loaded. If the value being\nloaded is of scalar type then the number of bytes read does not exceed\nthe minimum number of bytes needed to hold all bits of the type. For\nexample, loading an <code>i24</code> reads at most three bytes. When\nloading a value of a type like <code>i20</code> with a size that is not\nan integral number of bytes, the result is undefined if the value was\nnot originally written using a store of the same type. If the value\nbeing loaded is of aggregate type, the bytes that correspond to padding\nmay be accessed but are ignored, because it is impossible to observe\npadding from the loaded aggregate value. If <code>&lt;pointer&gt;</code>\nis not a well-defined value, the behavior is undefined.</p>\n<h2 id=\"examples\">Examples:</h2>\n<pre class=\"llvm\"><code>%ptr = alloca i32                               ; yields i32*:ptr\nstore i32 3, i32* %ptr                          ; yields void\n%val = load i32, i32* %ptr                      ; yields i32:val = i32 3</code></pre>\n",
  "store": "<h1 id=\"i_store\">'<code>store</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>store [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;[, align &lt;alignment&gt;][, !nontemporal !&lt;nontemp_node&gt;][, !invariant.group !&lt;empty_node&gt;]        ; yields void\nstore atomic [volatile] &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt;, align &lt;alignment&gt; [, !invariant.group !&lt;empty_node&gt;] ; yields void\n!&lt;nontemp_node&gt; = !{ i32 1 }\n!&lt;empty_node&gt; = !{}</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>store</code>' instruction is used to write to memory.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>There are two arguments to the <code>store</code> instruction: a\nvalue to store and an address at which to store it. The type of the\n<code>&lt;pointer&gt;</code> operand must be a pointer to the <code\nclass=\"interpreted-text\"\nrole=\"ref\">first class &lt;t_firstclass&gt;</code> type of the\n<code>&lt;value&gt;</code> operand. If the <code>store</code> is marked\nas <code>volatile</code>, then the optimizer is not allowed to modify\nthe number or order of execution of this <code>store</code> with other\n<code class=\"interpreted-text\"\nrole=\"ref\">volatile operations &lt;volatile&gt;</code>. Only values of\n<code class=\"interpreted-text\" role=\"ref\">first class\n&lt;t_firstclass&gt;</code> types of known size (i.e. not containing an\n<code class=\"interpreted-text\" role=\"ref\">opaque\nstructural type &lt;t_opaque&gt;</code>) can be stored.</p>\n<p>If the <code>store</code> is marked as <code>atomic</code>, it takes\nan extra <code class=\"interpreted-text\" role=\"ref\">ordering\n&lt;ordering&gt;</code> and optional\n<code>syncscope(\"&lt;target-scope&gt;\")</code> argument. The\n<code>acquire</code> and <code>acq_rel</code> orderings aren't valid on\n<code>store</code> instructions. Atomic loads produce <code\nclass=\"interpreted-text\" role=\"ref\">defined &lt;memmodel&gt;</code>\nresults when they may see multiple atomic stores. The type of the\npointee must be an integer, pointer, or floating-point type whose bit\nwidth is a power of two greater than or equal to eight and less than or\nequal to a target-specific size limit. <code>align</code> must be\nexplicitly specified on atomic stores, and the store has undefined\nbehavior if the alignment is not set to a value which is at least the\nsize in bytes of the pointee. <code>!nontemporal</code> does not have\nany defined semantics for atomic stores.</p>\n<p>The optional constant <code>align</code> argument specifies the\nalignment of the operation (that is, the alignment of the memory\naddress). A value of 0 or an omitted <code>align</code> argument means\nthat the operation has the ABI alignment for the target. It is the\nresponsibility of the code emitter to ensure that the alignment\ninformation is correct. Overestimating the alignment results in\nundefined behavior. Underestimating the alignment may produce less\nefficient code. An alignment of 1 is always safe. The maximum possible\nalignment is <code>1 &lt;&lt; 32</code>. An alignment value higher than\nthe size of the stored type implies memory up to the alignment value\nbytes can be stored to without trapping in the default address space.\nStoring to the higher bytes however may result in data races if another\nthread can access the same address. Introducing a data race is not\nallowed. Storing to the extra bytes is not allowed even in situations\nwhere a data race is known to not exist if the function has the\n<code>sanitize_address</code> attribute.</p>\n<p>The optional <code>!nontemporal</code> metadata must reference a\nsingle metadata name <code>&lt;nontemp_node&gt;</code> corresponding to\na metadata node with one <code>i32</code> entry of value 1. The\nexistence of the <code>!nontemporal</code> metadata on the instruction\ntells the optimizer and code generator that this load is not expected to\nbe reused in the cache. The code generator may select special\ninstructions to save cache bandwidth, such as the <code>MOVNT</code>\ninstruction on x86.</p>\n<p>The optional <code>!invariant.group</code> metadata must reference a\nsingle metadata name <code>&lt;empty_node&gt;</code>. See\n<code>invariant.group</code> metadata.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The contents of memory are updated to contain\n<code>&lt;value&gt;</code> at the location specified by the\n<code>&lt;pointer&gt;</code> operand. If <code>&lt;value&gt;</code> is\nof scalar type then the number of bytes written does not exceed the\nminimum number of bytes needed to hold all bits of the type. For\nexample, storing an <code>i24</code> writes at most three bytes. When\nwriting a value of a type like <code>i20</code> with a size that is not\nan integral number of bytes, it is unspecified what happens to the extra\nbits that do not belong to the type, but they will typically be\noverwritten. If <code>&lt;value&gt;</code> is of aggregate type, padding\nis filled with <code class=\"interpreted-text\"\nrole=\"ref\">undef &lt;undefvalues&gt;</code>. If\n<code>&lt;pointer&gt;</code> is not a well-defined value, the behavior\nis undefined.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%ptr = alloca i32                               ; yields i32*:ptr\nstore i32 3, i32* %ptr                          ; yields void\n%val = load i32, i32* %ptr                      ; yields i32:val = i32 3</code></pre>\n",
  "fence": "<h1 id=\"i_fence\">'<code>fence</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>fence [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt;  ; yields void</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fence</code>' instruction is used to introduce\nhappens-before edges between operations.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>'<code>fence</code>' instructions take an <code\nclass=\"interpreted-text\" role=\"ref\">ordering &lt;ordering&gt;</code>\nargument which defines what <em>synchronizes-with</em> edges they add.\nThey can only be given <code>acquire</code>, <code>release</code>,\n<code>acq_rel</code>, and <code>seq_cst</code> orderings.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>A fence A which has (at least) <code>release</code> ordering\nsemantics <em>synchronizes with</em> a fence B with (at least)\n<code>acquire</code> ordering semantics if and only if there exist\natomic operations X and Y, both operating on some atomic object M, such\nthat A is sequenced before X, X modifies M (either directly or through\nsome side effect of a sequence headed by X), Y is sequenced before B,\nand Y observes M. This provides a <em>happens-before</em> dependency\nbetween A and B. Rather than an explicit <code>fence</code>, one (but\nnot both) of the atomic operations X or Y might provide a\n<code>release</code> or <code>acquire</code> (resp.) ordering constraint\nand still <em>synchronize-with</em> the explicit <code>fence</code> and\nestablish the <em>happens-before</em> edge.</p>\n<p>A <code>fence</code> which has <code>seq_cst</code> ordering, in\naddition to having both <code>acquire</code> and <code>release</code>\nsemantics specified above, participates in the global program order of\nother <code>seq_cst</code> operations and/or fences.</p>\n<p>A <code>fence</code> instruction can also take an optional \"<code\nclass=\"interpreted-text\" role=\"ref\">syncscope &lt;syncscope&gt;</code>\"\nargument.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>fence acquire                                        ; yields void\nfence syncscope(&quot;singlethread&quot;) seq_cst              ; yields void\nfence syncscope(&quot;agent&quot;) seq_cst                     ; yields void</code></pre>\n",
  "cmpxchg": "<h1 id=\"i_cmpxchg\">'<code>cmpxchg</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>cmpxchg [weak] [volatile] &lt;ty&gt;* &lt;pointer&gt;, &lt;ty&gt; &lt;cmp&gt;, &lt;ty&gt; &lt;new&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;success ordering&gt; &lt;failure ordering&gt;[, align &lt;alignment&gt;] ; yields  { ty, i1 }</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>cmpxchg</code>' instruction is used to atomically modify\nmemory. It loads a value in memory and compares it to a given value. If\nthey are equal, it tries to store a new value into the memory.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>There are three arguments to the '<code>cmpxchg</code>' instruction:\nan address to operate on, a value to compare to the value currently be\nat that address, and a new value to place at that address if the\ncompared values are equal. The type of '&lt;cmp&gt;' must be an integer\nor pointer type whose bit width is a power of two greater than or equal\nto eight and less than or equal to a target-specific size limit.\n'&lt;cmp&gt;' and '&lt;new&gt;' must have the same type, and the type of\n'&lt;pointer&gt;' must be a pointer to that type. If the\n<code>cmpxchg</code> is marked as <code>volatile</code>, then the\noptimizer is not allowed to modify the number or order of execution of\nthis <code>cmpxchg</code> with other <code class=\"interpreted-text\"\nrole=\"ref\">volatile operations &lt;volatile&gt;</code>.</p>\n<p>The success and failure <code class=\"interpreted-text\"\nrole=\"ref\">ordering &lt;ordering&gt;</code> arguments specify how this\n<code>cmpxchg</code> synchronizes with other atomic operations. Both\nordering parameters must be at least <code>monotonic</code>, the failure\nordering cannot be either <code>release</code> or\n<code>acq_rel</code>.</p>\n<p>A <code>cmpxchg</code> instruction can also take an optional \"<code\nclass=\"interpreted-text\" role=\"ref\">syncscope &lt;syncscope&gt;</code>\"\nargument.</p>\n<p>The instruction can take an optional <code>align</code> attribute.\nThe alignment must be a power of two greater or equal to the size of the\n<span class=\"title-ref\">&lt;value&gt;</span> type. If unspecified, the\nalignment is assumed to be equal to the size of the '&lt;value&gt;'\ntype. Note that this default alignment assumption is different from the\nalignment used for the load/store instructions when align isn't\nspecified.</p>\n<p>The pointer passed into cmpxchg must have alignment greater than or\nequal to the size in memory of the operand.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The contents of memory at the location specified by the\n'<code>&lt;pointer&gt;</code>' operand is read and compared to\n'<code>&lt;cmp&gt;</code>'; if the values are equal,\n'<code>&lt;new&gt;</code>' is written to the location. The original\nvalue at the location is returned, together with a flag indicating\nsuccess (true) or failure (false).</p>\n<p>If the cmpxchg operation is marked as <code>weak</code> then a\nspurious failure is permitted: the operation may not write\n<code>&lt;new&gt;</code> even if the comparison matched.</p>\n<p>If the cmpxchg operation is strong (the default), the i1 value is 1\nif and only if the value loaded equals <code>cmp</code>.</p>\n<p>A successful <code>cmpxchg</code> is a read-modify-write instruction\nfor the purpose of identifying release sequences. A failed\n<code>cmpxchg</code> is equivalent to an atomic load with an ordering\nparameter determined the second ordering parameter.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>entry:\n  %orig = load atomic i32, i32* %ptr unordered, align 4                      ; yields i32\n  br label %loop\n\nloop:\n  %cmp = phi i32 [ %orig, %entry ], [%value_loaded, %loop]\n  %squared = mul i32 %cmp, %cmp\n  %val_success = cmpxchg i32* %ptr, i32 %cmp, i32 %squared acq_rel monotonic ; yields  { i32, i1 }\n  %value_loaded = extractvalue { i32, i1 } %val_success, 0\n  %success = extractvalue { i32, i1 } %val_success, 1\n  br i1 %success, label %done, label %loop\n\ndone:\n  ...</code></pre>\n",
  "atomicrmw": "<h1 id=\"i_atomicrmw\">'<code>atomicrmw</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>atomicrmw [volatile] &lt;operation&gt; &lt;ty&gt;* &lt;pointer&gt;, &lt;ty&gt; &lt;value&gt; [syncscope(&quot;&lt;target-scope&gt;&quot;)] &lt;ordering&gt;[, align &lt;alignment&gt;]  ; yields ty</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>atomicrmw</code>' instruction is used to atomically modify\nmemory.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>There are three arguments to the '<code>atomicrmw</code>'\ninstruction: an operation to apply, an address whose value to modify, an\nargument to the operation. The operation must be one of the following\nkeywords:</p>\n<ul>\n<li>xchg</li>\n<li>add</li>\n<li>sub</li>\n<li>and</li>\n<li>nand</li>\n<li>or</li>\n<li>xor</li>\n<li>max</li>\n<li>min</li>\n<li>umax</li>\n<li>umin</li>\n<li>fadd</li>\n<li>fsub</li>\n</ul>\n<p>For most of these operations, the type of '&lt;value&gt;' must be an\ninteger type whose bit width is a power of two greater than or equal to\neight and less than or equal to a target-specific size limit. For xchg,\nthis may also be a floating point type with the same size constraints as\nintegers. For fadd/fsub, this must be a floating point type. The type of\nthe '<code>&lt;pointer&gt;</code>' operand must be a pointer to that\ntype. If the <code>atomicrmw</code> is marked as <code>volatile</code>,\nthen the optimizer is not allowed to modify the number or order of\nexecution of this <code>atomicrmw</code> with other <code\nclass=\"interpreted-text\"\nrole=\"ref\">volatile operations &lt;volatile&gt;</code>.</p>\n<p>The instruction can take an optional <code>align</code> attribute.\nThe alignment must be a power of two greater or equal to the size of the\n<span class=\"title-ref\">&lt;value&gt;</span> type. If unspecified, the\nalignment is assumed to be equal to the size of the '&lt;value&gt;'\ntype. Note that this default alignment assumption is different from the\nalignment used for the load/store instructions when align isn't\nspecified.</p>\n<p>A <code>atomicrmw</code> instruction can also take an optional \"<code\nclass=\"interpreted-text\" role=\"ref\">syncscope &lt;syncscope&gt;</code>\"\nargument.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The contents of memory at the location specified by the\n'<code>&lt;pointer&gt;</code>' operand are atomically read, modified,\nand written back. The original value at the location is returned. The\nmodification is specified by the operation argument:</p>\n<ul>\n<li>xchg: <code>*ptr = val</code></li>\n<li>add: <code>*ptr = *ptr + val</code></li>\n<li>sub: <code>*ptr = *ptr - val</code></li>\n<li>and: <code>*ptr = *ptr &amp; val</code></li>\n<li>nand: <code>*ptr = ~(*ptr &amp; val)</code></li>\n<li>or: <code>*ptr = *ptr | val</code></li>\n<li>xor: <code>*ptr = *ptr ^ val</code></li>\n<li>max: <code>*ptr = *ptr &gt; val ? *ptr : val</code> (using a signed\ncomparison)</li>\n<li>min: <code>*ptr = *ptr &lt; val ? *ptr : val</code> (using a signed\ncomparison)</li>\n<li>umax: <code>*ptr = *ptr &gt; val ? *ptr : val</code> (using an\nunsigned comparison)</li>\n<li>umin: <code>*ptr = *ptr &lt; val ? *ptr : val</code> (using an\nunsigned comparison)</li>\n<li>fadd: <code>*ptr = *ptr + val</code> (using floating point\narithmetic)</li>\n<li>fsub: <code>*ptr = *ptr - val</code> (using floating point\narithmetic)</li>\n</ul>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%old = atomicrmw add i32* %ptr, i32 1 acquire                        ; yields i32</code></pre>\n",
  "getelementptr": "<h1 id=\"i_getelementptr\">'<code>getelementptr</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;{, [inrange] &lt;ty&gt; &lt;idx&gt;}*\n&lt;result&gt; = getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;{, [inrange] &lt;ty&gt; &lt;idx&gt;}*\n&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>getelementptr</code>' instruction is used to get the\naddress of a subelement of an <code class=\"interpreted-text\"\nrole=\"ref\">aggregate &lt;t_aggregate&gt;</code> data structure. It\nperforms address calculation only and does not access memory. The\ninstruction can also be used to calculate a vector of such\naddresses.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The first argument is always a type used as the basis for the\ncalculations. The second argument is always a pointer or a vector of\npointers, and is the base address to start from. The remaining arguments\nare indices that indicate which of the elements of the aggregate object\nare indexed. The interpretation of each index is dependent on the type\nbeing indexed into. The first index always indexes the pointer value\ngiven as the second argument, the second index indexes a value of the\ntype pointed to (not necessarily the value directly pointed to, since\nthe first index can be non-zero), etc. The first type indexed into must\nbe a pointer value, subsequent types can be arrays, vectors, and\nstructs. Note that subsequent types being indexed into can never be\npointers, since that would require loading the pointer before continuing\ncalculation.</p>\n<p>The type of each index argument depends on the type it is indexing\ninto. When indexing into a (optionally packed) structure, only\n<code>i32</code> integer <strong>constants</strong> are allowed (when\nusing a vector of indices they must all be the <strong>same</strong>\n<code>i32</code> integer constant). When indexing into an array, pointer\nor vector, integers of any width are allowed, and they are not required\nto be constant. These integers are treated as signed values where\nrelevant.</p>\n<p>For example, let's consider a C code fragment and how it gets\ncompiled to LLVM:</p>\n<pre class=\"c\"><code>struct RT {\n  char A;\n  int B[10][20];\n  char C;\n};\nstruct ST {\n  int X;\n  double Y;\n  struct RT Z;\n};\n\nint *foo(struct ST *s) {\n  return &amp;s[1].Z.B[5][13];\n}</code></pre>\n<p>The LLVM code generated by Clang is:</p>\n<pre class=\"llvm\"><code>%struct.RT = type { i8, [10 x [20 x i32]], i8 }\n%struct.ST = type { i32, double, %struct.RT }\n\ndefine i32* @foo(%struct.ST* %s) nounwind uwtable readnone optsize ssp {\nentry:\n  %arrayidx = getelementptr inbounds %struct.ST, %struct.ST* %s, i64 1, i32 2, i32 1, i64 5, i64 13\n  ret i32* %arrayidx\n}</code></pre>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>In the example above, the first index is indexing into the\n'<code>%struct.ST*</code>' type, which is a pointer, yielding a\n'<code>%struct.ST</code>' = '<code>{ i32, double, %struct.RT }</code>'\ntype, a structure. The second index indexes into the third element of\nthe structure, yielding a '<code>%struct.RT</code>' =\n'<code>{ i8 , [10 x [20 x i32]], i8 }</code>' type, another structure.\nThe third index indexes into the second element of the structure,\nyielding a '<code>[10 x [20 x i32]]</code>' type, an array. The two\ndimensions of the array are subscripted into, yielding an\n'<code>i32</code>' type. The '<code>getelementptr</code>' instruction\nreturns a pointer to this element, thus computing a value of\n'<code>i32*</code>' type.</p>\n<p>Note that it is perfectly legal to index partially through a\nstructure, returning a pointer to an inner element. Because of this, the\nLLVM code for the given testcase is equivalent to:</p>\n<pre class=\"llvm\"><code>define i32* @foo(%struct.ST* %s) {\n  %t1 = getelementptr %struct.ST, %struct.ST* %s, i32 1                        ; yields %struct.ST*:%t1\n  %t2 = getelementptr %struct.ST, %struct.ST* %t1, i32 0, i32 2                ; yields %struct.RT*:%t2\n  %t3 = getelementptr %struct.RT, %struct.RT* %t2, i32 0, i32 1                ; yields [10 x [20 x i32]]*:%t3\n  %t4 = getelementptr [10 x [20 x i32]], [10 x [20 x i32]]* %t3, i32 0, i32 5  ; yields [20 x i32]*:%t4\n  %t5 = getelementptr [20 x i32], [20 x i32]* %t4, i32 0, i32 13               ; yields i32*:%t5\n  ret i32* %t5\n}</code></pre>\n<p>If the <code>inbounds</code> keyword is present, the result value of\nthe <code>getelementptr</code> is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code> if one of the\nfollowing rules is violated:</p>\n<ul>\n<li>The base pointer has an <em>in bounds</em> address of an allocated\nobject, which means that it points into an allocated object, or to its\nend. The only <em>in bounds</em> address for a null pointer in the\ndefault address-space is the null pointer itself.</li>\n<li>If the type of an index is larger than the pointer index type, the\ntruncation to the pointer index type preserves the signed value.</li>\n<li>The multiplication of an index by the type size does not wrap the\npointer index type in a signed sense (<code>nsw</code>).</li>\n<li>The successive addition of offsets (without adding the base address)\ndoes not wrap the pointer index type in a signed sense\n(<code>nsw</code>).</li>\n<li>The successive addition of the current address, interpreted as an\nunsigned number, and an offset, interpreted as a signed number, does not\nwrap the unsigned address space and remains <em>in bounds</em> of the\nallocated object. As a corollary, if the added offset is non-negative,\nthe addition does not wrap in an unsigned sense (<code>nuw</code>).</li>\n<li>In cases where the base is a vector of pointers, the\n<code>inbounds</code> keyword applies to each of the computations\nelement-wise.</li>\n</ul>\n<p>These rules are based on the assumption that no allocated object may\ncross the unsigned address space boundary, and no allocated object may\nbe larger than half the pointer index type space.</p>\n<p>If the <code>inbounds</code> keyword is not present, the offsets are\nadded to the base address with silently-wrapping two's complement\narithmetic. If the offsets have a different width from the pointer, they\nare sign-extended or truncated to the width of the pointer. The result\nvalue of the <code>getelementptr</code> may be outside the object\npointed to by the base pointer. The result value may not necessarily be\nused to access memory though, even if it happens to point into allocated\nstorage. See the <code class=\"interpreted-text\"\nrole=\"ref\">Pointer Aliasing Rules &lt;pointeraliasing&gt;</code> section\nfor more information.</p>\n<p>If the <code>inrange</code> keyword is present before any index,\nloading from or storing to any pointer derived from the\n<code>getelementptr</code> has undefined behavior if the load or store\nwould access memory outside of the bounds of the element selected by the\nindex marked as <code>inrange</code>. The result of a pointer comparison\nor <code>ptrtoint</code> (including <code>ptrtoint</code>-like\noperations involving memory) involving a pointer derived from a\n<code>getelementptr</code> with the <code>inrange</code> keyword is\nundefined, with the exception of comparisons in the case where both\noperands are in the range of the element selected by the\n<code>inrange</code> keyword, inclusive of the address one past the end\nof that element. Note that the <code>inrange</code> keyword is currently\nonly allowed in constant <code>getelementptr</code> expressions.</p>\n<p>The getelementptr instruction is often confusing. For some more\ninsight into how it works, see <code class=\"interpreted-text\"\nrole=\"doc\">the getelementptr FAQ &lt;GetElementPtr&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>; yields [12 x i8]*:aptr\n%aptr = getelementptr {i32, [12 x i8]}, {i32, [12 x i8]}* %saptr, i64 0, i32 1\n; yields i8*:vptr\n%vptr = getelementptr {i32, &lt;2 x i8&gt;}, {i32, &lt;2 x i8&gt;}* %svptr, i64 0, i32 1, i32 1\n; yields i8*:eptr\n%eptr = getelementptr [12 x i8], [12 x i8]* %aptr, i64 0, i32 1\n; yields i32*:iptr\n%iptr = getelementptr [10 x i32], [10 x i32]* @arr, i16 0, i16 0</code></pre>\n<h2 id=\"vector-of-pointers\">Vector of pointers:</h2>\n<p>The <code>getelementptr</code> returns a vector of pointers, instead\nof a single address, when one or more of its arguments is a vector. In\nsuch cases, all vector arguments should have the same number of\nelements, and every scalar argument will be effectively broadcast into a\nvector during address calculation.</p>\n<pre class=\"llvm\"><code>; All arguments are vectors:\n;   A[i] = ptrs[i] + offsets[i]*sizeof(i8)\n%A = getelementptr i8, &lt;4 x i8*&gt; %ptrs, &lt;4 x i64&gt; %offsets\n\n; Add the same scalar offset to each pointer of a vector:\n;   A[i] = ptrs[i] + offset*sizeof(i8)\n%A = getelementptr i8, &lt;4 x i8*&gt; %ptrs, i64 %offset\n\n; Add distinct offsets to the same pointer:\n;   A[i] = ptr + offsets[i]*sizeof(i8)\n%A = getelementptr i8, i8* %ptr, &lt;4 x i64&gt; %offsets\n\n; In all cases described above the type of the result is &lt;4 x i8*&gt;</code></pre>\n<p>The two following instructions are equivalent:</p>\n<pre class=\"llvm\"><code>getelementptr  %struct.ST, &lt;4 x %struct.ST*&gt; %s, &lt;4 x i64&gt; %ind1,\n  &lt;4 x i32&gt; &lt;i32 2, i32 2, i32 2, i32 2&gt;,\n  &lt;4 x i32&gt; &lt;i32 1, i32 1, i32 1, i32 1&gt;,\n  &lt;4 x i32&gt; %ind4,\n  &lt;4 x i64&gt; &lt;i64 13, i64 13, i64 13, i64 13&gt;\n\ngetelementptr  %struct.ST, &lt;4 x %struct.ST*&gt; %s, &lt;4 x i64&gt; %ind1,\n  i32 2, i32 1, &lt;4 x i32&gt; %ind4, i64 13</code></pre>\n<p>Let's look at the C code, where the vector version of\n<code>getelementptr</code> makes sense:</p>\n<pre class=\"c\"><code>// Let&#39;s assume that we vectorize the following loop:\ndouble *A, *B; int *C;\nfor (int i = 0; i &lt; size; ++i) {\n  A[i] = B[C[i]];\n}</code></pre>\n<pre class=\"llvm\"><code>; get pointers for 8 elements from array B\n%ptrs = getelementptr double, double* %B, &lt;8 x i32&gt; %C\n; load 8 elements from array B into A\n%A = call &lt;8 x double&gt; @llvm.masked.gather.v8f64.v8p0f64(&lt;8 x double*&gt; %ptrs,\n     i32 8, &lt;8 x i1&gt; %mask, &lt;8 x double&gt; %passthru)</code></pre>\n<h3 id=\"conversion-operations\">Conversion Operations</h3>\n<p>The instructions in this category are the conversion instructions\n(casting) which all take a single operand and a type. They perform\nvarious bit conversions on the operand.</p>\n",
  "trunc": "<h1 id=\"i_trunc\">'<code>trunc .. to</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = trunc &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>trunc</code>' instruction truncates its operand to the\ntype <code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>trunc</code>' instruction takes a value to trunc, and a\ntype to trunc it to. Both types must be of <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code>\ntypes, or vectors of the same number of integers. The bit size of the\n<code>value</code> must be larger than the bit size of the destination\ntype, <code>ty2</code>. Equal sized types are not allowed.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>trunc</code>' instruction truncates the high order bits in\n<code>value</code> and converts the remaining bits to <code>ty2</code>.\nSince the source size must be larger than the destination size,\n<code>trunc</code> cannot be a <em>no-op cast</em>. It will always\ntruncate bits.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = trunc i32 257 to i8                        ; yields i8:1\n%Y = trunc i32 123 to i1                        ; yields i1:true\n%Z = trunc i32 122 to i1                        ; yields i1:false\n%W = trunc &lt;2 x i16&gt; &lt;i16 8, i16 7&gt; to &lt;2 x i8&gt; ; yields &lt;i8 8, i8 7&gt;</code></pre>\n",
  "zext": "<h1 id=\"i_zext\">'<code>zext .. to</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = zext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>zext</code>' instruction zero extends its operand to type\n<code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>zext</code>' instruction takes a value to cast, and a type\nto cast it to. Both types must be of <code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> types, or vectors of the\nsame number of integers. The bit size of the <code>value</code> must be\nsmaller than the bit size of the destination type, <code>ty2</code>.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The <code>zext</code> fills the high order bits of the\n<code>value</code> with zero bits until it reaches the size of the\ndestination type, <code>ty2</code>.</p>\n<p>When zero extending from i1, the result will always be either 0 or\n1.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = zext i32 257 to i64              ; yields i64:257\n%Y = zext i1 true to i32              ; yields i32:1\n%Z = zext &lt;2 x i16&gt; &lt;i16 8, i16 7&gt; to &lt;2 x i32&gt; ; yields &lt;i32 8, i32 7&gt;</code></pre>\n",
  "sext": "<h1 id=\"i_sext\">'<code>sext .. to</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = sext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>sext</code>' sign extends <code>value</code> to the type\n<code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>sext</code>' instruction takes a value to cast, and a type\nto cast it to. Both types must be of <code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> types, or vectors of the\nsame number of integers. The bit size of the <code>value</code> must be\nsmaller than the bit size of the destination type, <code>ty2</code>.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>sext</code>' instruction performs a sign extension by\ncopying the sign bit (highest order bit) of the <code>value</code> until\nit reaches the bit size of the type <code>ty2</code>.</p>\n<p>When sign extending from i1, the extension always results in -1 or\n0.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = sext i8  -1 to i16              ; yields i16   :65535\n%Y = sext i1 true to i32             ; yields i32:-1\n%Z = sext &lt;2 x i16&gt; &lt;i16 8, i16 7&gt; to &lt;2 x i32&gt; ; yields &lt;i32 8, i32 7&gt;</code></pre>\n",
  "fptrunc": "<h1 id=\"fptrunc-..-to-instruction\">'<code>fptrunc .. to</code>'\nInstruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fptrunc &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fptrunc</code>' instruction truncates <code>value</code>\nto type <code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>fptrunc</code>' instruction takes a <code\nclass=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> value to cast and a\n<code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> type to cast it to.\nThe size of <code>value</code> must be larger than the size of\n<code>ty2</code>. This implies that <code>fptrunc</code> cannot be used\nto make a <em>no-op cast</em>.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>fptrunc</code>' instruction casts a <code>value</code>\nfrom a larger <code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> type to a smaller\n<code class=\"interpreted-text\" role=\"ref\">floating-point\n&lt;t_floating&gt;</code> type. This instruction is assumed to execute\nin the default <code class=\"interpreted-text\" role=\"ref\">floating-point\nenvironment &lt;floatenv&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = fptrunc double 16777217.0 to float    ; yields float:16777216.0\n%Y = fptrunc double 1.0E+300 to half       ; yields half:+infinity</code></pre>\n",
  "fpext": "<h1 id=\"fpext-..-to-instruction\">'<code>fpext .. to</code>'\nInstruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fpext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fpext</code>' extends a floating-point <code>value</code>\nto a larger floating-point value.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>fpext</code>' instruction takes a <code\nclass=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> <code>value</code>\nto cast, and a <code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> type to cast it to.\nThe source type must be smaller than the destination type.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>fpext</code>' instruction extends the <code>value</code>\nfrom a smaller <code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> type to a larger\n<code class=\"interpreted-text\" role=\"ref\">floating-point\n&lt;t_floating&gt;</code> type. The <code>fpext</code> cannot be used to\nmake a <em>no-op cast</em> because it always changes bits. Use\n<code>bitcast</code> to make a <em>no-op cast</em> for a floating-point\ncast.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = fpext float 3.125 to double         ; yields double:3.125000e+00\n%Y = fpext double %X to fp128            ; yields fp128:0xL00000000000000004000900000000000</code></pre>\n",
  "fptoui": "<h1 id=\"fptoui-..-to-instruction\">'<code>fptoui .. to</code>'\nInstruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fptoui &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fptoui</code>' converts a floating-point\n<code>value</code> to its unsigned integer equivalent of type\n<code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>fptoui</code>' instruction takes a value to cast, which\nmust be a scalar or vector <code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> value, and a type to\ncast it to <code>ty2</code>, which must be an <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code>\ntype. If <code>ty</code> is a vector floating-point type,\n<code>ty2</code> must be a vector integer type with the same number of\nelements as <code>ty</code></p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>fptoui</code>' instruction converts its <code\nclass=\"interpreted-text\" role=\"ref\">floating-point\n&lt;t_floating&gt;</code> operand into the nearest (rounding towards\nzero) unsigned integer value. If the value cannot fit in\n<code>ty2</code>, the result is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = fptoui double 123.0 to i32      ; yields i32:123\n%Y = fptoui float 1.0E+300 to i1     ; yields undefined:1\n%Z = fptoui float 1.04E+17 to i8     ; yields undefined:1</code></pre>\n",
  "fptosi": "<h1 id=\"fptosi-..-to-instruction\">'<code>fptosi .. to</code>'\nInstruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fptosi &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fptosi</code>' instruction converts <code\nclass=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> <code>value</code>\nto type <code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>fptosi</code>' instruction takes a value to cast, which\nmust be a scalar or vector <code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> value, and a type to\ncast it to <code>ty2</code>, which must be an <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code>\ntype. If <code>ty</code> is a vector floating-point type,\n<code>ty2</code> must be a vector integer type with the same number of\nelements as <code>ty</code></p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>fptosi</code>' instruction converts its <code\nclass=\"interpreted-text\" role=\"ref\">floating-point\n&lt;t_floating&gt;</code> operand into the nearest (rounding towards\nzero) signed integer value. If the value cannot fit in <code>ty2</code>,\nthe result is a <code class=\"interpreted-text\"\nrole=\"ref\">poison value &lt;poisonvalues&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = fptosi double -123.0 to i32      ; yields i32:-123\n%Y = fptosi float 1.0E-247 to i1      ; yields undefined:1\n%Z = fptosi float 1.04E+17 to i8      ; yields undefined:1</code></pre>\n",
  "uitofp": "<h1 id=\"uitofp-..-to-instruction\">'<code>uitofp .. to</code>'\nInstruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = uitofp &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>uitofp</code>' instruction regards <code>value</code> as\nan unsigned integer and converts that value to the <code>ty2</code>\ntype.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>uitofp</code>' instruction takes a value to cast, which\nmust be a scalar or vector <code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> value, and a type to cast it\nto <code>ty2</code>, which must be an <code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> type. If\n<code>ty</code> is a vector integer type, <code>ty2</code> must be a\nvector floating-point type with the same number of elements as\n<code>ty</code></p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>uitofp</code>' instruction interprets its operand as an\nunsigned integer quantity and converts it to the corresponding\nfloating-point value. If the value cannot be exactly represented, it is\nrounded using the default rounding mode.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = uitofp i32 257 to float         ; yields float:257.0\n%Y = uitofp i8 -1 to double          ; yields double:255.0</code></pre>\n",
  "sitofp": "<h1 id=\"sitofp-..-to-instruction\">'<code>sitofp .. to</code>'\nInstruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = sitofp &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>sitofp</code>' instruction regards <code>value</code> as a\nsigned integer and converts that value to the <code>ty2</code> type.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>sitofp</code>' instruction takes a value to cast, which\nmust be a scalar or vector <code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> value, and a type to cast it\nto <code>ty2</code>, which must be an <code class=\"interpreted-text\"\nrole=\"ref\">floating-point &lt;t_floating&gt;</code> type. If\n<code>ty</code> is a vector integer type, <code>ty2</code> must be a\nvector floating-point type with the same number of elements as\n<code>ty</code></p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>sitofp</code>' instruction interprets its operand as a\nsigned integer quantity and converts it to the corresponding\nfloating-point value. If the value cannot be exactly represented, it is\nrounded using the default rounding mode.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = sitofp i32 257 to float         ; yields float:257.0\n%Y = sitofp i8 -1 to double          ; yields double:-1.0</code></pre>\n",
  "ptrtoint": "<h1 id=\"i_ptrtoint\">'<code>ptrtoint .. to</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = ptrtoint &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>ptrtoint</code>' instruction converts the pointer or a\nvector of pointers <code>value</code> to the integer (or vector of\nintegers) type <code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>ptrtoint</code>' instruction takes a <code>value</code> to\ncast, which must be a value of type <code class=\"interpreted-text\"\nrole=\"ref\">pointer &lt;t_pointer&gt;</code> or a vector of pointers, and\na type to cast it to <code>ty2</code>, which must be an <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code> or\na vector of integers type.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>ptrtoint</code>' instruction converts <code>value</code>\nto integer type <code>ty2</code> by interpreting the pointer value as an\ninteger and either truncating or zero extending that value to the size\nof the integer type. If <code>value</code> is smaller than\n<code>ty2</code> then a zero extension is done. If <code>value</code> is\nlarger than <code>ty2</code> then a truncation is done. If they are the\nsame size, then nothing is done (<em>no-op cast</em>) other than a type\nchange.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = ptrtoint i32* %P to i8                         ; yields truncation on 32-bit architecture\n%Y = ptrtoint i32* %P to i64                        ; yields zero extension on 32-bit architecture\n%Z = ptrtoint &lt;4 x i32*&gt; %P to &lt;4 x i64&gt;; yields vector zero extension for a vector of addresses on 32-bit architecture</code></pre>\n",
  "inttoptr": "<h1 id=\"i_inttoptr\">'<code>inttoptr .. to</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = inttoptr &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;[, !dereferenceable !&lt;deref_bytes_node&gt;][, !dereferenceable_or_null !&lt;deref_bytes_node&gt;]             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>inttoptr</code>' instruction converts an integer\n<code>value</code> to a pointer type, <code>ty2</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>inttoptr</code>' instruction takes an <code\nclass=\"interpreted-text\" role=\"ref\">integer &lt;t_integer&gt;</code>\nvalue to cast, and a type to cast it to, which must be a <code\nclass=\"interpreted-text\" role=\"ref\">pointer &lt;t_pointer&gt;</code>\ntype.</p>\n<p>The optional <code>!dereferenceable</code> metadata must reference a\nsingle metadata name <code>&lt;deref_bytes_node&gt;</code> corresponding\nto a metadata node with one <code>i64</code> entry. See\n<code>dereferenceable</code> metadata.</p>\n<p>The optional <code>!dereferenceable_or_null</code> metadata must\nreference a single metadata name <code>&lt;deref_bytes_node&gt;</code>\ncorresponding to a metadata node with one <code>i64</code> entry. See\n<code>dereferenceable_or_null</code> metadata.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>inttoptr</code>' instruction converts <code>value</code>\nto type <code>ty2</code> by applying either a zero extension or a\ntruncation depending on the size of the integer <code>value</code>. If\n<code>value</code> is larger than the size of a pointer then a\ntruncation is done. If <code>value</code> is smaller than the size of a\npointer then a zero extension is done. If they are the same size,\nnothing is done (<em>no-op cast</em>).</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = inttoptr i32 255 to i32*          ; yields zero extension on 64-bit architecture\n%Y = inttoptr i32 255 to i32*          ; yields no-op on 32-bit architecture\n%Z = inttoptr i64 0 to i32*            ; yields truncation on 32-bit architecture\n%Z = inttoptr &lt;4 x i32&gt; %G to &lt;4 x i8*&gt;; yields truncation of vector G to four pointers</code></pre>\n",
  "bitcast": "<h1 id=\"i_bitcast\">'<code>bitcast .. to</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = bitcast &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;             ; yields ty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>bitcast</code>' instruction converts <code>value</code> to\ntype <code>ty2</code> without changing any bits.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>bitcast</code>' instruction takes a value to cast, which\nmust be a non-aggregate first class value, and a type to cast it to,\nwhich must also be a non-aggregate <code class=\"interpreted-text\"\nrole=\"ref\">first class &lt;t_firstclass&gt;</code> type. The bit sizes\nof <code>value</code> and the destination type, <code>ty2</code>, must\nbe identical. If the source type is a pointer, the destination type must\nalso be a pointer of the same size. This instruction supports bitwise\nconversion of vectors to integers and to vectors of other types (as long\nas they have the same size).</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>bitcast</code>' instruction converts <code>value</code> to\ntype <code>ty2</code>. It is always a <em>no-op cast</em> because no\nbits change with this conversion. The conversion is done as if the\n<code>value</code> had been stored to memory and read back as type\n<code>ty2</code>. Pointer (or vector of pointers) types may only be\nconverted to other pointer (or vector of pointers) types with the same\naddress space through this instruction. To convert pointers to other\ntypes, use the <code class=\"interpreted-text\"\nrole=\"ref\">inttoptr &lt;i_inttoptr&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">ptrtoint &lt;i_ptrtoint&gt;</code>\ninstructions first.</p>\n<p>There is a caveat for bitcasts involving vector types in relation to\nendianess. For example\n<code>bitcast &lt;2 x i8&gt; &lt;value&gt; to i16</code> puts element\nzero of the vector in the least significant bits of the i16 for\nlittle-endian while element zero ends up in the most significant bits\nfor big-endian.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>%X = bitcast i8 255 to i8          ; yields i8 :-1\n%Y = bitcast i32* %x to i16*      ; yields i16*:%x\n%Z = bitcast &lt;2 x i32&gt; %V to i64;  ; yields i64: %V (depends on endianess)\n%Z = bitcast &lt;2 x i32*&gt; %V to &lt;2 x i64*&gt; ; yields &lt;2 x i64*&gt;</code></pre>\n",
  "addrspacecast": "<h1 id=\"i_addrspacecast\">'<code>addrspacecast .. to</code>'\nInstruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = addrspacecast &lt;pty&gt; &lt;ptrval&gt; to &lt;pty2&gt;       ; yields pty2</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>addrspacecast</code>' instruction converts\n<code>ptrval</code> from <code>pty</code> in address space\n<code>n</code> to type <code>pty2</code> in address space\n<code>m</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>addrspacecast</code>' instruction takes a pointer or\nvector of pointer value to cast and a pointer type to cast it to, which\nmust have a different address space.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>addrspacecast</code>' instruction converts the pointer\nvalue <code>ptrval</code> to type <code>pty2</code>. It can be a\n<em>no-op cast</em> or a complex value modification, depending on the\ntarget and the address space pair. Pointer conversions within the same\naddress space must be performed with the <code>bitcast</code>\ninstruction. Note that if the address space conversion is legal then\nboth result and operand refer to the same memory location.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = addrspacecast i32* %x to i32 addrspace(1)*    ; yields i32 addrspace(1)*:%x\n%Y = addrspacecast i32 addrspace(1)* %y to i64 addrspace(2)*    ; yields i64 addrspace(2)*:%y\n%Z = addrspacecast &lt;4 x i32*&gt; %z to &lt;4 x float addrspace(3)*&gt;   ; yields &lt;4 x float addrspace(3)*&gt;:%z</code></pre>\n",
  "icmp": "<h1 id=\"i_icmp\">'<code>icmp</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields i1 or &lt;N x i1&gt;:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>icmp</code>' instruction returns a boolean value or a\nvector of boolean values based on comparison of its two integer, integer\nvector, pointer, or pointer vector operands.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>icmp</code>' instruction takes three operands. The first\noperand is the condition code indicating the kind of comparison to\nperform. It is not a value, just a keyword. The possible condition codes\nare:</p>\n<ol>\n<li><code>eq</code>: equal</li>\n<li><code>ne</code>: not equal</li>\n<li><code>ugt</code>: unsigned greater than</li>\n<li><code>uge</code>: unsigned greater or equal</li>\n<li><code>ult</code>: unsigned less than</li>\n<li><code>ule</code>: unsigned less or equal</li>\n<li><code>sgt</code>: signed greater than</li>\n<li><code>sge</code>: signed greater or equal</li>\n<li><code>slt</code>: signed less than</li>\n<li><code>sle</code>: signed less or equal</li>\n</ol>\n<p>The remaining two arguments must be <code class=\"interpreted-text\"\nrole=\"ref\">integer &lt;t_integer&gt;</code> or <code\nclass=\"interpreted-text\" role=\"ref\">pointer &lt;t_pointer&gt;</code> or\ninteger <code class=\"interpreted-text\"\nrole=\"ref\">vector &lt;t_vector&gt;</code> typed. They must also be\nidentical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>icmp</code>' compares <code>op1</code> and\n<code>op2</code> according to the condition code given as\n<code>cond</code>. The comparison performed always yields either an\n<code class=\"interpreted-text\" role=\"ref\">i1 &lt;t_integer&gt;</code> or\nvector of <code>i1</code> result, as follows:</p>\n<ol>\n<li><code>eq</code>: yields <code>true</code> if the operands are equal,\n<code>false</code> otherwise. No sign interpretation is necessary or\nperformed.</li>\n<li><code>ne</code>: yields <code>true</code> if the operands are\nunequal, <code>false</code> otherwise. No sign interpretation is\nnecessary or performed.</li>\n<li><code>ugt</code>: interprets the operands as unsigned values and\nyields <code>true</code> if <code>op1</code> is greater than\n<code>op2</code>.</li>\n<li><code>uge</code>: interprets the operands as unsigned values and\nyields <code>true</code> if <code>op1</code> is greater than or equal to\n<code>op2</code>.</li>\n<li><code>ult</code>: interprets the operands as unsigned values and\nyields <code>true</code> if <code>op1</code> is less than\n<code>op2</code>.</li>\n<li><code>ule</code>: interprets the operands as unsigned values and\nyields <code>true</code> if <code>op1</code> is less than or equal to\n<code>op2</code>.</li>\n<li><code>sgt</code>: interprets the operands as signed values and\nyields <code>true</code> if <code>op1</code> is greater than\n<code>op2</code>.</li>\n<li><code>sge</code>: interprets the operands as signed values and\nyields <code>true</code> if <code>op1</code> is greater than or equal to\n<code>op2</code>.</li>\n<li><code>slt</code>: interprets the operands as signed values and\nyields <code>true</code> if <code>op1</code> is less than\n<code>op2</code>.</li>\n<li><code>sle</code>: interprets the operands as signed values and\nyields <code>true</code> if <code>op1</code> is less than or equal to\n<code>op2</code>.</li>\n</ol>\n<p>If the operands are <code class=\"interpreted-text\"\nrole=\"ref\">pointer &lt;t_pointer&gt;</code> typed, the pointer values\nare compared as if they were integers.</p>\n<p>If the operands are integer vectors, then they are compared element\nby element. The result is an <code>i1</code> vector with the same number\nof elements as the values being compared. Otherwise, the result is an\n<code>i1</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = icmp eq i32 4, 5          ; yields: result=false\n&lt;result&gt; = icmp ne float* %X, %X     ; yields: result=false\n&lt;result&gt; = icmp ult i16  4, 5        ; yields: result=true\n&lt;result&gt; = icmp sgt i16  4, 5        ; yields: result=false\n&lt;result&gt; = icmp ule i16 -4, 5        ; yields: result=false\n&lt;result&gt; = icmp sge i16  4, 5        ; yields: result=false</code></pre>\n",
  "fcmp": "<h1 id=\"i_fcmp\">'<code>fcmp</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = fcmp [fast-math flags]* &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;     ; yields i1 or &lt;N x i1&gt;:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>fcmp</code>' instruction returns a boolean value or vector\nof boolean values based on comparison of its operands.</p>\n<p>If the operands are floating-point scalars, then the result type is a\nboolean (<code class=\"interpreted-text\"\nrole=\"ref\">i1 &lt;t_integer&gt;</code>).</p>\n<p>If the operands are floating-point vectors, then the result type is a\nvector of boolean with the same number of elements as the operands being\ncompared.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>fcmp</code>' instruction takes three operands. The first\noperand is the condition code indicating the kind of comparison to\nperform. It is not a value, just a keyword. The possible condition codes\nare:</p>\n<ol>\n<li><code>false</code>: no comparison, always returns false</li>\n<li><code>oeq</code>: ordered and equal</li>\n<li><code>ogt</code>: ordered and greater than</li>\n<li><code>oge</code>: ordered and greater than or equal</li>\n<li><code>olt</code>: ordered and less than</li>\n<li><code>ole</code>: ordered and less than or equal</li>\n<li><code>one</code>: ordered and not equal</li>\n<li><code>ord</code>: ordered (no nans)</li>\n<li><code>ueq</code>: unordered or equal</li>\n<li><code>ugt</code>: unordered or greater than</li>\n<li><code>uge</code>: unordered or greater than or equal</li>\n<li><code>ult</code>: unordered or less than</li>\n<li><code>ule</code>: unordered or less than or equal</li>\n<li><code>une</code>: unordered or not equal</li>\n<li><code>uno</code>: unordered (either nans)</li>\n<li><code>true</code>: no comparison, always returns true</li>\n</ol>\n<p><em>Ordered</em> means that neither operand is a QNAN while\n<em>unordered</em> means that either operand may be a QNAN.</p>\n<p>Each of <code>val1</code> and <code>val2</code> arguments must be\neither a <code class=\"interpreted-text\" role=\"ref\">floating-point\n&lt;t_floating&gt;</code> type or a <code class=\"interpreted-text\"\nrole=\"ref\">vector &lt;t_vector&gt;</code> of floating-point type. They\nmust have identical types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>fcmp</code>' instruction compares <code>op1</code> and\n<code>op2</code> according to the condition code given as\n<code>cond</code>. If the operands are vectors, then the vectors are\ncompared element by element. Each comparison performed always yields an\n<code class=\"interpreted-text\" role=\"ref\">i1 &lt;t_integer&gt;</code>\nresult, as follows:</p>\n<ol>\n<li><code>false</code>: always yields <code>false</code>, regardless of\noperands.</li>\n<li><code>oeq</code>: yields <code>true</code> if both operands are not\na QNAN and <code>op1</code> is equal to <code>op2</code>.</li>\n<li><code>ogt</code>: yields <code>true</code> if both operands are not\na QNAN and <code>op1</code> is greater than <code>op2</code>.</li>\n<li><code>oge</code>: yields <code>true</code> if both operands are not\na QNAN and <code>op1</code> is greater than or equal to\n<code>op2</code>.</li>\n<li><code>olt</code>: yields <code>true</code> if both operands are not\na QNAN and <code>op1</code> is less than <code>op2</code>.</li>\n<li><code>ole</code>: yields <code>true</code> if both operands are not\na QNAN and <code>op1</code> is less than or equal to\n<code>op2</code>.</li>\n<li><code>one</code>: yields <code>true</code> if both operands are not\na QNAN and <code>op1</code> is not equal to <code>op2</code>.</li>\n<li><code>ord</code>: yields <code>true</code> if both operands are not\na QNAN.</li>\n<li><code>ueq</code>: yields <code>true</code> if either operand is a\nQNAN or <code>op1</code> is equal to <code>op2</code>.</li>\n<li><code>ugt</code>: yields <code>true</code> if either operand is a\nQNAN or <code>op1</code> is greater than <code>op2</code>.</li>\n<li><code>uge</code>: yields <code>true</code> if either operand is a\nQNAN or <code>op1</code> is greater than or equal to\n<code>op2</code>.</li>\n<li><code>ult</code>: yields <code>true</code> if either operand is a\nQNAN or <code>op1</code> is less than <code>op2</code>.</li>\n<li><code>ule</code>: yields <code>true</code> if either operand is a\nQNAN or <code>op1</code> is less than or equal to <code>op2</code>.</li>\n<li><code>une</code>: yields <code>true</code> if either operand is a\nQNAN or <code>op1</code> is not equal to <code>op2</code>.</li>\n<li><code>uno</code>: yields <code>true</code> if either operand is a\nQNAN.</li>\n<li><code>true</code>: always yields <code>true</code>, regardless of\noperands.</li>\n</ol>\n<p>The <code>fcmp</code> instruction can also optionally take any number\nof <code class=\"interpreted-text\"\nrole=\"ref\">fast-math flags &lt;fastmath&gt;</code>, which are\noptimization hints to enable otherwise unsafe floating-point\noptimizations.</p>\n<p>Any set of fast-math flags are legal on an <code>fcmp</code>\ninstruction, but the only flags that have any effect on its semantics\nare those that allow assumptions to be made about the values of input\narguments; namely <code>nnan</code>, <code>ninf</code>, and\n<code>reassoc</code>. See <code class=\"interpreted-text\"\nrole=\"ref\">fastmath</code> for more information.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>&lt;result&gt; = fcmp oeq float 4.0, 5.0    ; yields: result=false\n&lt;result&gt; = fcmp one float 4.0, 5.0    ; yields: result=true\n&lt;result&gt; = fcmp olt float 4.0, 5.0    ; yields: result=true\n&lt;result&gt; = fcmp ueq double 1.0, 2.0   ; yields: result=false</code></pre>\n",
  "phi": "<h1 id=\"i_phi\">'<code>phi</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = phi [fast-math-flags] &lt;ty&gt; [ &lt;val0&gt;, &lt;label0&gt;], ...</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>phi</code>' instruction is used to implement the \u00cf\u2020 node in\nthe SSA graph representing the function.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The type of the incoming values is specified with the first type\nfield. After this, the '<code>phi</code>' instruction takes a list of\npairs as arguments, with one pair for each predecessor basic block of\nthe current block. Only values of <code class=\"interpreted-text\"\nrole=\"ref\">first class &lt;t_firstclass&gt;</code> type may be used as\nthe value arguments to the PHI node. Only labels may be used as the\nlabel arguments.</p>\n<p>There must be no non-phi instructions between the start of a basic\nblock and the PHI instructions: i.e. PHI instructions must be first in a\nbasic block.</p>\n<p>For the purposes of the SSA form, the use of each incoming value is\ndeemed to occur on the edge from the corresponding predecessor block to\nthe current block (but after any definition of an '<code>invoke</code>'\ninstruction's return value on the same edge).</p>\n<p>The optional <code>fast-math-flags</code> marker indicates that the\nphi has one or more <code class=\"interpreted-text\"\nrole=\"ref\">fast-math-flags &lt;fastmath&gt;</code>. These are\noptimization hints to enable otherwise unsafe floating-point\noptimizations. Fast-math-flags are only valid for phis that return a\nfloating-point scalar or vector type, or an array (nested to any depth)\nof floating-point scalar or vector types.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>At runtime, the '<code>phi</code>' instruction logically takes on the\nvalue specified by the pair corresponding to the predecessor basic block\nthat executed just prior to the current block.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>Loop:       ; Infinite loop that counts from 0 on up...\n  %indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]\n  %nextindvar = add i32 %indvar, 1\n  br label %Loop</code></pre>\n",
  "select": "<h1 id=\"i_select\">'<code>select</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = select [fast-math flags] selty &lt;cond&gt;, &lt;ty&gt; &lt;val1&gt;, &lt;ty&gt; &lt;val2&gt;             ; yields ty\n\nselty is either i1 or {&lt;N x i1&gt;}</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>select</code>' instruction is used to choose one value\nbased on a condition, without IR-level branching.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>select</code>' instruction requires an 'i1' value or a\nvector of 'i1' values indicating the condition, and two values of the\nsame <code class=\"interpreted-text\" role=\"ref\">first\nclass &lt;t_firstclass&gt;</code> type.</p>\n<ol>\n<li>The optional <code>fast-math flags</code> marker indicates that the\nselect has one or more <code class=\"interpreted-text\"\nrole=\"ref\">fast-math flags &lt;fastmath&gt;</code>. These are\noptimization hints to enable otherwise unsafe floating-point\noptimizations. Fast-math flags are only valid for selects that return a\nfloating-point scalar or vector type, or an array (nested to any depth)\nof floating-point scalar or vector types.</li>\n</ol>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>If the condition is an i1 and it evaluates to 1, the instruction\nreturns the first value argument; otherwise, it returns the second value\nargument.</p>\n<p>If the condition is a vector of i1, then the value arguments must be\nvectors of the same size, and the selection is done element by\nelement.</p>\n<p>If the condition is an i1 and the value arguments are vectors of the\nsame size, then an entire vector is selected.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%X = select i1 true, i8 17, i8 42          ; yields i8:17</code></pre>\n",
  "freeze": "<h1 id=\"i_freeze\">'<code>freeze</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = freeze ty &lt;val&gt;    ; yields ty:result</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>freeze</code>' instruction is used to stop propagation of\n<code class=\"interpreted-text\"\nrole=\"ref\">undef &lt;undefvalues&gt;</code> and <code\nclass=\"interpreted-text\" role=\"ref\">poison &lt;poisonvalues&gt;</code>\nvalues.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The '<code>freeze</code>' instruction takes a single argument.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>If the argument is <code>undef</code> or <code>poison</code>,\n'<code>freeze</code>' returns an arbitrary, but fixed, value of type\n'<code>ty</code>'. Otherwise, this instruction is a no-op and returns\nthe input argument. All uses of a value returned by the same\n'<code>freeze</code>' instruction are guaranteed to always observe the\nsame value, while different '<code>freeze</code>' instructions may yield\ndifferent values.</p>\n<p>While <code>undef</code> and <code>poison</code> pointers can be\nfrozen, the result is a non-dereferenceable pointer. See the <code\nclass=\"interpreted-text\"\nrole=\"ref\">Pointer Aliasing Rules &lt;pointeraliasing&gt;</code> section\nfor more information. If an aggregate value or vector is frozen, the\noperand is frozen element-wise. The padding of an aggregate isn't\nconsidered, since it isn't visible without storing it into memory and\nloading it with a different type.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>%w = i32 undef\n%x = freeze i32 %w\n%y = add i32 %w, %w         ; undef\n%z = add i32 %x, %x         ; even number because all uses of %x observe\n                            ; the same value\n%x2 = freeze i32 %w\n%cmp = icmp eq i32 %x, %x2  ; can be true or false\n\n; example with vectors\n%v = &lt;2 x i32&gt; &lt;i32 undef, i32 poison&gt;\n%a = extractelement &lt;2 x i32&gt; %v, i32 0    ; undef\n%b = extractelement &lt;2 x i32&gt; %v, i32 1    ; poison\n%add = add i32 %a, %a                      ; undef\n\n%v.fr = freeze &lt;2 x i32&gt; %v                ; element-wise freeze\n%d = extractelement &lt;2 x i32&gt; %v.fr, i32 0 ; not undef\n%add.f = add i32 %d, %d                    ; even number\n\n; branching on frozen value\n%poison = add nsw i1 %k, undef   ; poison\n%c = freeze i1 %poison\nbr i1 %c, label %foo, label %bar ; non-deterministic branch to %foo or %bar</code></pre>\n",
  "call": "<h1 id=\"i_call\">'<code>call</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;result&gt; = [tail | musttail | notail ] call [fast-math flags] [cconv] [ret attrs] [addrspace(&lt;num&gt;)]\n           &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;) [fn attrs] [ operand bundles ]</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>call</code>' instruction represents a simple function\ncall.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>This instruction requires several arguments:</p>\n<ol>\n<li><p>The optional <code>tail</code> and <code>musttail</code> markers\nindicate that the optimizers should perform tail call optimization. The\n<code>tail</code> marker is a hint that <a\nhref=\"https://releases.llvm.org/14.0.0/docs/CodeGenerator.html#sibling-call-optimization\">can be ignored</a>. The\n<code>musttail</code> marker means that the call must be tail call\noptimized in order for the program to be correct. The\n<code>musttail</code> marker provides these guarantees:</p>\n<ol>\n<li>The call will not cause unbounded stack growth if it is part of a\nrecursive cycle in the call graph.</li>\n<li>Arguments with the <code class=\"interpreted-text\"\nrole=\"ref\">inalloca &lt;attr_inalloca&gt;</code> or <code\nclass=\"interpreted-text\"\nrole=\"ref\">preallocated &lt;attr_preallocated&gt;</code> attribute are\nforwarded in place.</li>\n<li>If the musttail call appears in a function with the\n<code>\"thunk\"</code> attribute and the caller and callee both have\nvarargs, than any unprototyped arguments in register or memory are\nforwarded to the callee. Similarly, the return value of the callee is\nreturned to the caller's caller, even if a void return type is in\nuse.</li>\n</ol>\n<p>Both markers imply that the callee does not access allocas from the\ncaller. The <code>tail</code> marker additionally implies that the\ncallee does not access varargs from the caller. Calls marked\n<code>musttail</code> must obey the following additional rules:</p>\n<ul>\n<li>The call must immediately precede a <code class=\"interpreted-text\"\nrole=\"ref\">ret &lt;i_ret&gt;</code> instruction, or a pointer bitcast\nfollowed by a ret instruction.</li>\n<li>The ret instruction must return the (possibly bitcasted) value\nproduced by the call, undef, or void.</li>\n<li>The calling conventions of the caller and callee must match.</li>\n<li>The callee must be varargs iff the caller is varargs. Bitcasting a\nnon-varargs function to the appropriate varargs type is legal so long as\nthe non-varargs prefixes obey the other rules.</li>\n<li>The return type must not undergo automatic conversion to an <span\nclass=\"title-ref\">sret</span> pointer.</li>\n</ul></li>\n</ol>\n<blockquote>\n<p>In addition, if the calling convention is not <span\nclass=\"title-ref\">swifttailcc</span> or `tailcc`:</p>\n<blockquote>\n<ul>\n<li>All ABI-impacting function attributes, such as sret, byval, inreg,\nreturned, and inalloca, must match.</li>\n<li>The caller and callee prototypes must match. Pointer types of\nparameters or return types may differ in pointee type, but not in\naddress space.</li>\n</ul>\n</blockquote>\n<p>On the other hand, if the calling convention is <span\nclass=\"title-ref\">swifttailcc</span> or `swiftcc`:</p>\n<blockquote>\n<ul>\n<li>Only these ABI-impacting attributes attributes are allowed: sret,\nbyval, swiftself, and swiftasync.</li>\n<li>Prototypes are not required to match.</li>\n</ul>\n<p>Tail call optimization for calls marked <code>tail</code> is\nguaranteed to occur if the following conditions are met:</p>\n<ul>\n<li>Caller and callee both have the calling convention\n<code>fastcc</code> or <code>tailcc</code>.</li>\n<li>The call is in tail position (ret immediately follows call and ret\nuses value of call or is void).</li>\n<li>Option <code>-tailcallopt</code> is enabled,\n<code>llvm::GuaranteedTailCallOpt</code> is <code>true</code>, or the\ncalling convention is <code>tailcc</code></li>\n<li><a href=\"https://releases.llvm.org/14.0.0/docs/CodeGenerator.html#tail-call-optimization\">Platform-specific\nconstraints are met.</a></li>\n</ul>\n</blockquote>\n</blockquote>\n<ol>\n<li>The optional <code>notail</code> marker indicates that the\noptimizers should not add <code>tail</code> or <code>musttail</code>\nmarkers to the call. It is used to prevent tail call optimization from\nbeing performed on the call.</li>\n<li>The optional <code>fast-math flags</code> marker indicates that the\ncall has one or more <code class=\"interpreted-text\"\nrole=\"ref\">fast-math flags &lt;fastmath&gt;</code>, which are\noptimization hints to enable otherwise unsafe floating-point\noptimizations. Fast-math flags are only valid for calls that return a\nfloating-point scalar or vector type, or an array (nested to any depth)\nof floating-point scalar or vector types.</li>\n<li>The optional \"cconv\" marker indicates which <code\nclass=\"interpreted-text\" role=\"ref\">calling\nconvention &lt;callingconv&gt;</code> the call should use. If none is\nspecified, the call defaults to using C calling conventions. The calling\nconvention of the call must match the calling convention of the target\nfunction, or else the behavior is undefined.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">Parameter Attributes &lt;paramattrs&gt;</code> list for\nreturn values. Only '<code>zeroext</code>', '<code>signext</code>', and\n'<code>inreg</code>' attributes are valid here.</li>\n<li>The optional addrspace attribute can be used to indicate the address\nspace of the called function. If it is not specified, the program\naddress space from the <code class=\"interpreted-text\"\nrole=\"ref\">datalayout string&lt;langref_datalayout&gt;</code> will be\nused.</li>\n<li>'<code>ty</code>': the type of the call instruction itself which is\nalso the type of the return value. Functions that return no value are\nmarked <code>void</code>.</li>\n<li>'<code>fnty</code>': shall be the signature of the function being\ncalled. The argument types must match the types implied by this\nsignature. This type can be omitted if the function is not varargs.</li>\n<li>'<code>fnptrval</code>': An LLVM value containing a pointer to a\nfunction to be called. In most cases, this is a direct function call,\nbut indirect <code>call</code>'s are just as possible, calling an\narbitrary pointer to function value.</li>\n<li>'<code>function args</code>': argument list whose types match the\nfunction signature argument types and parameter attributes. All\narguments must be of <code class=\"interpreted-text\"\nrole=\"ref\">first class &lt;t_firstclass&gt;</code> type. If the function\nsignature indicates the function accepts a variable number of arguments,\nthe extra arguments can be specified.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">function attributes &lt;fnattrs&gt;</code> list.</li>\n<li>The optional <code class=\"interpreted-text\"\nrole=\"ref\">operand bundles &lt;opbundles&gt;</code> list.</li>\n</ol>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>call</code>' instruction is used to cause control flow to\ntransfer to a specified function, with its incoming arguments bound to\nthe specified values. Upon a '<code>ret</code>' instruction in the\ncalled function, control flow continues with the instruction after the\nfunction call, and the return value of the function is bound to the\nresult argument.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>%retval = call i32 @test(i32 %argc)\ncall i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)        ; yields i32\n%X = tail call i32 @foo()                                    ; yields i32\n%Y = tail call fastcc i32 @foo()  ; yields i32\ncall void %foo(i8 signext 97)\n\n%struct.A = type { i32, i8 }\n%r = call %struct.A @foo()                        ; yields { i32, i8 }\n%gr = extractvalue %struct.A %r, 0                ; yields i32\n%gr1 = extractvalue %struct.A %r, 1               ; yields i8\n%Z = call void @foo() noreturn                    ; indicates that %foo never returns normally\n%ZZ = call zeroext i32 @bar()                     ; Return value is %zero extended</code></pre>\n<p>llvm treats calls to some functions with names and arguments that\nmatch the standard C99 library as being the C99 library functions, and\nmay perform optimizations or generate code for them under that\nassumption. This is something we'd like to change in the future to\nprovide better support for freestanding environments and non-C-based\nlanguages.</p>\n",
  "va_arg": "<h1 id=\"i_va_arg\">'<code>va_arg</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;resultval&gt; = va_arg &lt;va_list*&gt; &lt;arglist&gt;, &lt;argty&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>va_arg</code>' instruction is used to access arguments\npassed through the \"variable argument\" area of a function call. It is\nused to implement the <code>va_arg</code> macro in C.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>This instruction takes a <code>va_list*</code> value and the type of\nthe argument. It returns a value of the specified argument type and\nincrements the <code>va_list</code> to point to the next argument. The\nactual type of <code>va_list</code> is target specific.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>va_arg</code>' instruction loads an argument of the\nspecified type from the specified <code>va_list</code> and causes the\n<code>va_list</code> to point to the next argument. For more\ninformation, see the variable argument handling <code\nclass=\"interpreted-text\"\nrole=\"ref\">Intrinsic Functions &lt;int_varargs&gt;</code>.</p>\n<p>It is legal for this instruction to be called in a function which\ndoes not take a variable number of arguments, for example, the\n<code>vfprintf</code> function.</p>\n<p><code>va_arg</code> is an LLVM instruction instead of an <code\nclass=\"interpreted-text\" role=\"ref\">intrinsic\nfunction &lt;intrinsics&gt;</code> because it takes a type as an\nargument.</p>\n<h2 id=\"example\">Example:</h2>\n<p>See the <code class=\"interpreted-text\"\nrole=\"ref\">variable argument processing &lt;int_varargs&gt;</code>\nsection.</p>\n<p>Note that the code generator does not yet fully support va_arg on\nmany targets. Also, it does not currently support va_arg with aggregate\ntypes on any target.</p>\n",
  "landingpad": "<h1 id=\"i_landingpad\">'<code>landingpad</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;resultval&gt; = landingpad &lt;resultty&gt; &lt;clause&gt;+\n&lt;resultval&gt; = landingpad &lt;resultty&gt; cleanup &lt;clause&gt;*\n\n&lt;clause&gt; := catch &lt;type&gt; &lt;value&gt;\n&lt;clause&gt; := filter &lt;array constant type&gt; &lt;array constant&gt;</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>landingpad</code>' instruction is used by <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#overview\">LLVM's exception handling\nsystem</a> to specify that a basic block is a landing pad --- one where\nthe exception lands, and corresponds to the code found in the\n<code>catch</code> portion of a <code>try</code>/<code>catch</code>\nsequence. It defines values supplied by the <code\nclass=\"interpreted-text\"\nrole=\"ref\">personality function &lt;personalityfn&gt;</code> upon\nre-entry to the function. The <code>resultval</code> has the type\n<code>resultty</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The optional <code>cleanup</code> flag indicates that the landing pad\nblock is a cleanup.</p>\n<p>A <code>clause</code> begins with the clause type ---\n<code>catch</code> or <code>filter</code> --- and contains the global\nvariable representing the \"type\" that may be caught or filtered\nrespectively. Unlike the <code>catch</code> clause, the\n<code>filter</code> clause takes an array constant as its argument. Use\n\"<code>[0 x i8**] undef</code>\" for a filter which cannot throw. The\n'<code>landingpad</code>' instruction must contain <em>at least</em> one\n<code>clause</code> or the <code>cleanup</code> flag.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>The '<code>landingpad</code>' instruction defines the values which\nare set by the <code class=\"interpreted-text\"\nrole=\"ref\">personality function &lt;personalityfn&gt;</code> upon\nre-entry to the function, and therefore the \"result type\" of the\n<code>landingpad</code> instruction. As with calling conventions, how\nthe personality function results are represented in LLVM IR is target\nspecific.</p>\n<p>The clauses are applied in order from top to bottom. If two\n<code>landingpad</code> instructions are merged together through\ninlining, the clauses from the calling function are appended to the list\nof clauses. When the call stack is being unwound due to an exception\nbeing thrown, the exception is compared against each <code>clause</code>\nin turn. If it doesn't match any of the clauses, and the\n<code>cleanup</code> flag is not set, then unwinding continues further\nup the call stack.</p>\n<p>The <code>landingpad</code> instruction has several restrictions:</p>\n<ul>\n<li>A landing pad block is a basic block which is the unwind destination\nof an '<code>invoke</code>' instruction.</li>\n<li>A landing pad block must have a '<code>landingpad</code>'\ninstruction as its first non-PHI instruction.</li>\n<li>There can be only one '<code>landingpad</code>' instruction within\nthe landing pad block.</li>\n<li>A basic block that is not a landing pad block may not include a\n'<code>landingpad</code>' instruction.</li>\n</ul>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"llvm\"><code>;; A landing pad which can catch an integer.\n%res = landingpad { i8*, i32 }\n         catch i8** @_ZTIi\n;; A landing pad that is a cleanup.\n%res = landingpad { i8*, i32 }\n         cleanup\n;; A landing pad which can catch an integer and can only throw a double.\n%res = landingpad { i8*, i32 }\n         catch i8** @_ZTIi\n         filter [1 x i8**] [i8** @_ZTId]</code></pre>\n",
  "catchpad": "<h1 id=\"i_catchpad\">'<code>catchpad</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;resultval&gt; = catchpad within &lt;catchswitch&gt; [&lt;args&gt;*]</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>catchpad</code>' instruction is used by <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#overview\">LLVM's exception handling\nsystem</a> to specify that a basic block begins a catch handler --- one\nwhere a personality routine attempts to transfer control to catch an\nexception.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The <code>catchswitch</code> operand must always be a token produced\nby a <code class=\"interpreted-text\"\nrole=\"ref\">catchswitch &lt;i_catchswitch&gt;</code> instruction in a\npredecessor block. This ensures that each <code>catchpad</code> has\nexactly one predecessor block, and it always terminates in a\n<code>catchswitch</code>.</p>\n<p>The <code>args</code> correspond to whatever information the\npersonality routine requires to know if this is an appropriate handler\nfor the exception. Control will transfer to the <code>catchpad</code> if\nthis is the first appropriate handler for the exception.</p>\n<p>The <code>resultval</code> has the type <code\nclass=\"interpreted-text\" role=\"ref\">token &lt;t_token&gt;</code> and is\nused to match the <code>catchpad</code> to corresponding <code\nclass=\"interpreted-text\" role=\"ref\">catchrets &lt;i_catchret&gt;</code>\nand other nested EH pads.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>When the call stack is being unwound due to an exception being\nthrown, the exception is compared against the <code>args</code>. If it\ndoesn't match, control will not reach the <code>catchpad</code>\ninstruction. The representation of <code>args</code> is entirely target\nand personality function-specific.</p>\n<p>Like the <code class=\"interpreted-text\"\nrole=\"ref\">landingpad &lt;i_landingpad&gt;</code> instruction, the\n<code>catchpad</code> instruction must be the first non-phi of its\nparent basic block.</p>\n<p>The meaning of the tokens produced and consumed by\n<code>catchpad</code> and other \"pad\" instructions is described in the\n<a href=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#wineh\">Windows exception handling\ndocumentation</a>.</p>\n<p>When a <code>catchpad</code> has been \"entered\" but not yet \"exited\"\n(as described in the <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#wineh-constraints\">EH documentation</a>),\nit is undefined behavior to execute a <code class=\"interpreted-text\"\nrole=\"ref\">call &lt;i_call&gt;</code> or <code class=\"interpreted-text\"\nrole=\"ref\">invoke &lt;i_invoke&gt;</code> that does not carry an\nappropriate <code class=\"interpreted-text\"\nrole=\"ref\">\"funclet\" bundle &lt;ob_funclet&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>dispatch:\n  %cs = catchswitch within none [label %handler0] unwind to caller\n  ;; A catch block which can catch an integer.\nhandler0:\n  %tok = catchpad within %cs [i8** @_ZTIi]</code></pre>\n",
  "cleanuppad": "<h1 id=\"i_cleanuppad\">'<code>cleanuppad</code>' Instruction</h1>\n<h2 id=\"syntax\">Syntax:</h2>\n<pre><code>&lt;resultval&gt; = cleanuppad within &lt;parent&gt; [&lt;args&gt;*]</code></pre>\n<h2 id=\"overview\">Overview:</h2>\n<p>The '<code>cleanuppad</code>' instruction is used by <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#overview\">LLVM's exception handling\nsystem</a> to specify that a basic block is a cleanup block --- one\nwhere a personality routine attempts to transfer control to run cleanup\nactions. The <code>args</code> correspond to whatever additional\ninformation the <code class=\"interpreted-text\"\nrole=\"ref\">personality function &lt;personalityfn&gt;</code> requires to\nexecute the cleanup. The <code>resultval</code> has the type <code\nclass=\"interpreted-text\" role=\"ref\">token &lt;t_token&gt;</code> and is\nused to match the <code>cleanuppad</code> to corresponding <code\nclass=\"interpreted-text\"\nrole=\"ref\">cleanuprets &lt;i_cleanupret&gt;</code>. The\n<code>parent</code> argument is the token of the funclet that contains\nthe <code>cleanuppad</code> instruction. If the <code>cleanuppad</code>\nis not inside a funclet, this operand may be the token\n<code>none</code>.</p>\n<h2 id=\"arguments\">Arguments:</h2>\n<p>The instruction takes a list of arbitrary values which are\ninterpreted by the <code class=\"interpreted-text\"\nrole=\"ref\">personality function &lt;personalityfn&gt;</code>.</p>\n<h2 id=\"semantics\">Semantics:</h2>\n<p>When the call stack is being unwound due to an exception being\nthrown, the <code class=\"interpreted-text\"\nrole=\"ref\">personality function &lt;personalityfn&gt;</code> transfers\ncontrol to the <code>cleanuppad</code> with the aid of the\npersonality-specific arguments. As with calling conventions, how the\npersonality function results are represented in LLVM IR is target\nspecific.</p>\n<p>The <code>cleanuppad</code> instruction has several restrictions:</p>\n<ul>\n<li>A cleanup block is a basic block which is the unwind destination of\nan exceptional instruction.</li>\n<li>A cleanup block must have a '<code>cleanuppad</code>' instruction as\nits first non-PHI instruction.</li>\n<li>There can be only one '<code>cleanuppad</code>' instruction within\nthe cleanup block.</li>\n<li>A basic block that is not a cleanup block may not include a\n'<code>cleanuppad</code>' instruction.</li>\n</ul>\n<p>When a <code>cleanuppad</code> has been \"entered\" but not yet\n\"exited\" (as described in the <a\nhref=\"https://releases.llvm.org/14.0.0/docs/ExceptionHandling.html#wineh-constraints\">EH documentation</a>),\nit is undefined behavior to execute a <code class=\"interpreted-text\"\nrole=\"ref\">call &lt;i_call&gt;</code> or <code class=\"interpreted-text\"\nrole=\"ref\">invoke &lt;i_invoke&gt;</code> that does not carry an\nappropriate <code class=\"interpreted-text\"\nrole=\"ref\">\"funclet\" bundle &lt;ob_funclet&gt;</code>.</p>\n<h2 id=\"example\">Example:</h2>\n<pre class=\"text\"><code>%tok = cleanuppad within %cs []</code></pre>\n"
}